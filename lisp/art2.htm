
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">


<title>GNU Common Lisp - часть 2, атомы и списки</title>
<meta name="Microsoft Theme" content="blueprnt 0000, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body bgcolor="#FFFFFF" text="#003399" link="#3366FF" vlink="#9900FF" alink="#000066"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p></p>
<p>&nbsp;<img src="../../images/cartonarmy.gif" alt="[Картонная Армия - от галеры до ракеты!]" border="0" width="468" height="60">
</p>
<p>
<a href="../../index.htm"><img src="../../_derived/home_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Домой" align="middle"></a> <a href="../gcl.htm"><img src="../../_derived/up_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Вверх" align="middle"></a> <a href="../../toc.htm"><img src="../../_derived/toc.htm_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Содержание" align="middle"></a></p>
<p>
<img src="_derived/art2.htm_cmp_blueprnt000_bnr.gif" width="600" height="60" border="0" alt="Lisp -атомы и списки">
<br>
<a href="art1.htm"><img src="_derived/art1.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - первые шаги" align="middle"></a> <img src="_derived/art2.htm_cmp_blueprnt000_hbtn_p.gif" width="140" height="60" border="0" alt="Lisp -атомы и списки" align="middle"> <a href="art3.htm"><img src="_derived/art3.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - переменные" align="middle"></a> <a href="art4.htm"><img src="_derived/art4.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - вызов функций" align="middle"></a> <a href="art5.htm"><img src="_derived/art5.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Программные блоки" align="middle"></a> <a href="art6.htm"><img src="_derived/art6.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Структуры данных" align="middle"></a>
</p>
<p>&nbsp;</p>

<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Times New Roman">
<p>&nbsp;</p>
<p><a href="http://">
</a>
</p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Times New Roman">
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>
<div align="Right">
  <h4>В.Водолазкий<br>
  </h4>
 </div>
 <br>
 <br>
 
<h2 align="center">Первые шаги в Common Lisp - атомы и списки</h2>
 <br>
 
<blockquote>   
  <blockquote>     
    <div align="Justify"><i>В статье рассматриваются основные "строительные
   кирпичики" языка Лисп - атомы и списки. Показывается, что этих компонентов
   в общем-то достаточно для решения многих  практических задач. Объясняется
   понятие предиката и  работа отдельных управляющих структур. </i></div>
     </blockquote>
     </blockquote>
     
    <div align="Justify"><br>
      В прошлой статье мы кратко познакомились с
      построением программы на
 Лиспе   и как я надеюсь, вы уже можете самостоятельно решать арифметические
 задачи   на этом языке. Но конечно же, первого знакомства для решения практических
   задач явно недостаточно. Поэтому нам придется бросить на Лисп второй пристальный
   взгляд, а затем еще несколько. В этот раз под наш микроскоп попадут основные
   структуры данных, на которых построена вся Лисп-система. Поскольку основные 
понятия Лиспа заметно отличаются от традиционных языков, я заранее прошу у
читателя извинения за "теоретическую подкладку", но без нее, увы, не обойтись...<br>
     
    <p>Возьмем сразу же быка за рога. С точки зрения чистой теории в Лиспе
   существует всего два типа данных - <b>атомы, </b>то есть некоторые объекты,
   не поддающиеся дальнейшему делению и являющиеся строительными кирпичами,
  из которых строится все остальное здание Лиспа, и <b>списки</b> - универсальная
   структура данных, которую можно сравнить со строительным раствором (цементом),
   с помощью которых атомы могут объединяться в сколь угодно сложные молекулы
   - то есть опять же списки. Универсальность списков заключается в том,
что    и сами определения функций Лиспа (в том числе и целые программы) представляются
   в Лисп-машине теми же самыми списками. Более того, Лисп-машина не делает
  никаких различий между списками, состоящими из данных пользователя и определениями
   функций - а это означает, что ваша программа вполне может самостоятельно
  сформировать новую функцию и выполнить ее! Это ли не торжество архитектуры
  фон Неймана!  </p>
     Отметим еще один факт, важный для дальнейшего изложения. Все что вы
видите   в Лиспе представляет собой объекты, которые
      принадлежат к одному,
или к  нескольким типам одновременно. В этом отношении Лисп также опередил
свое время на многие десятилетия и в нем объектно-ориентированный подход,
как вы впоследствии увидите, реализован исключительно ярко и удобно.<br>
     <br>
     Конечно, за 40 лет эволюции языка Лисп в нем появилось немало производных 
  типов данных, которые предназначены для решения тех или иных специфичных 
 задач. Сегодня Common Lisp поддерживает работу с разнообразными типами объектов. 
  Это важная оговорка ---  в Лиспе тип имеют не переменные, а именно объекты, 
  в которых размещены те или иные данные. При этом любая переменная может 
иметь  в качестве значения объект произвольного типа. <br>
     <br>
     
    <blockquote>       
      <blockquote>
        <p><i><small>Конечно, вы можете ввести объявление, указывающее 
  на то, что переменная может принимать только ограниченный 
  набор значений. Однако такие ограничения могут быть 
  легко обойдены, но программа при этом все равно будет 
  работать вполне корректно. Поэтому такие объявления 
  используются просто в качестве подсказки системе от
  пользователя, направленной на повышение эффективности
     работы интерпретатора Лисп.</small></i><br>
        </p>
         </blockquote>
         </blockquote>
         <br>
         
        <h3>Алмазные россыпи - типы данных в Common Lisp</h3>
     Тип данных в Common Lisp представляет собой множество (возможно, бесконечное), 
  объектов Лиспа. Многие из объектов при этом принадлежат сразу к
      нескольким подобным множествам, поэтому на практике вопрос <i>``какому конкретному 
типу принадлежит тот или иной объект?''          </i> оказывается не 
всегда корректным. Поэтому обычно вопрос задается иначе: <i>``Принадлежит 
ли тот  или иной объект некоторому типу?''</i> Практическое воплощение этого 
вопроса  представляет собой предикат <b>typep</b>, но можно использовать и
функцию          <b>type-of</b>, которая возвращает тип (или вернее, один 
из типов), которому принадлежит заданный объект.<br>
        <br>
        <blockquote>
          <blockquote><small>Немножко отвлечемся... Под <b>
предикатом</b> в Лиспе понимают функцию, которая предназначена
для проверки выполнения некоторого условия и возвращает
            <b>
T </b>в случае выполнения этого условия и <b>
NIL</b> в противном случае. Кроме того, поскольку любое отличное
от NIL значение в функциях сравнения интерпретируется как
            T,  предикат может
выглядеть, например, следующим образом:<br>
            <br>
 </small><!--mstheme--></font><pre><small><font color="#000000">(defun правильный-размерчик? (арг)</font></small></pre><!--mstheme--><font face="Times New Roman">
            <!--mstheme--></font><pre><small><font color="#000000">&nbsp; &nbsp; (if (and (&lt; арг 100) (&gt; арг 50)) &nbsp; арг &nbsp;nil)</font></small></pre><!--mstheme--><font face="Times New Roman">
            <!--mstheme--></font><pre><small><font color="#000000">)</font></small></pre><!--mstheme--><font face="Times New Roman">
            <small><br>
            В этом примере функция возвращает аргумент, если
его значение находится в диапазоне от 50 до 100, а если это ограничение не
выполняется, возвращается NIL. Опознать предикат по имени функции обычно
достаточно легко - в Common Lisp принято соглашение, по которому имена функций-предикатов
заканчиваются буквой <b>p </b>(латинской).
А в некоторых других диалектах, таких как например,
            Schema, имя предиката
заканчивается вопросительным знаком.<br>
            </small></blockquote>
            </blockquote>
            <br>
         <br>
     Типы данных, определенные в Common Lisp, представляют собой частично
упорядоченную   иерархию, задаваемую в виде отношения
      подмножеств. Определенные множества объектов, такие как множество чисел
  или множество строк, используются достаточно часто, чтобы
      получить собственные обозначения. В качестве этих обозначений используются 
  обычные символы (Под термином <b> символ</b> в Лиспе и в этой статье понимается 
  некий атомарный объект, известный также под названием <b>литерал</b>. <br>
         <br>
     Множество всех объектов объявляется с помощью символа <b>T, </b>который
  представляет собой сокращение от TRUE (истина). Соответственно, пустой
тип   данных, который не включает ни одного объекта, объявляется как <b>NIL</b>
    . Реализован также тип <b>common</b>, в котором объединяются все типы<br>
     данных, обязательных для всех реализаций  Common
      Lisp. Впрочем, любая
 версия  может поддерживать и дополнительные типы данных, которые не являются
 подтипами          <b>common</b>. Проверка того или иного типа на принадлежность
 к этому  множеству может быть выполнена с помощью предиката <b>commonp</b>
  .<br>
         <br>
     Особый интерес при разработке программного обеспечения представляет
несколько   классов объектов  Common Lisp: числа, буквы, символы, списки,
массивы, структуры   и функции. Некоторые из этих
      категорий сами содержат
разнообразные группы.   А кроме того, существуют и стандартные объединения
двух и более категорий,   которые имеют собственные названия.<br>
         <br>
     Перечисленные выше категории, в тех случаях, когда они используются
как   типы данных, могут рассматриваться как ``реальные'' типы данных; фактически,
  эти категории формируют полезные срезы в иерархии типов, предназначенные
 для тех или иных конкретных задач.<br>
         <br>
     Ниже приведены краткие описания различных типов данных Common
      Lisp.
Конечно   для практической работы этих знаний маловато, но вы должны по крайней
мере   представлять с чем придется столкнуться в ходе работы с Лиспом.<br>
         <br>
         <b>Числа</b> в Лиспе, вопреки расхожему мнению о ``слабой поддержке 
  арифметики'' в этом языке представлены широким набором форм и видов представлений. 
  Common Lisp поддерживает полноценную работу с целыми: <i>любое</i> целое 
 число , будь оно положительное или отрицательное, может быть представлено 
 как объект Лиспа. Единственным ограничением на этом пути может служить только 
 общий объем памяти, а не длина машинного слова. В Common Lisp реализована 
 также поддержка дробей - результат деления двух целых чисел, представляет 
 собой дробь, если только он не является целым числом. Точно так же в состав 
 типов данных, поддерживаемых Лиспом, входят и числа с плавающей запятой<br>
     различных диапазонов и точностей, а также картезианские комплексные
числа,   знакомые всем нам по школьному курсу математики.<br>
         <br>
         <b>Буквы</b> представляют собой печатные изображения, повсеместно 
  используемые при форматировании текстов. Строки, в свою очередь, рассматриваются 
  как одномерные массивы, состоящие из букв. В Common Lisp предусмотрена поддержка
  обширных наборов букв, включая механизмы представления букв различных типов
  стилей.<br>
         <br>
         <b>Символы</b> (Иногда называемые также  <i>атомарными символами</i>
     , чтобы подчеркнуть специфику их использования) представляют собой именованные 
  объекты данных. Лисп содержит механизмы для выявления объекта по его имени 
  (в формате строки). Символы имеют <i> списки свойств</i>, которые на практике 
  позволяют интерпретировать символы как структуры с расширяемым множеством 
  именованных компонентов, каждый из которых может представлять собой произвольный 
  объект Лиспа. Символы используются также для именования функций и переменных 
  внутри программ.<br>
         <br>
         <b>Списки</b> представляют собой последовательности, представленные 
  в форме  связанных ячеек, называемых <i>cons</i>-ячейками. Существует специальный 
  объект (символ NIL, который также обозначается как <b>'()</b>), который 
обозначает  пустой список. Все остальные списки строятся рекурсивным образом 
путем добавления  нового элемента к началу уже существующего списка. Эта операция
выполняется  путем создания новой <b>cons</b>-ячейки, представляющей собой
объект, имеющий  два компонента, называемых  <b>car</b> и  <b>cdr</b>   частями.
Часть <b> car</b>   может быть пустой, а <b>cdr</b>-часть должна указывать
на ранее существующий  список.<br>
         <br>
         <b>Массивы</b> представляют собой индексированные собрания объектов. 
  Массив может иметь любое неотрицательное число измерений и
      индексируется последовательностью целых чисел. В общем случае массив может содержать в 
качестве компонента любой объект Лиспа; однако предусмотрены и некоторые специализированные
версии массивов, которые предназначены для хранения элементов только определенных
типов. Допускается, чтобы два массива, возможно, имеющие различное количество
измерений, использовали один и тот же набор элементов совместно (При этом
модификация одного массива приводит к модификации и другого). Эта ситуация
используется достаточно часто и называется <i>смещением</i> одного массива
относительно другого.  Одномерные массивы любого вида называются        
 <b>векторами</b>. Одномерные массивы, содержащие буквы, называются     
   <b>строками</b>. Одномерные массивы битов, то есть целых чисел, которые 
  могут иметь значения только 0 или 1, называются <b> битовыми векторами</b>
     .<br>
         <br>
         <b>Хэш-таблицы</b> предназначены для реализации эффективного механизма 
  отображения любого объекта Лиспа, представляющего собой  <i>ключ</i> на 
ассоциируемый  с этим ключом объект.<br>
         <br>
         <b>Таблицы чтения</b> используются для управления встроенным в функцию 
          <b>read</b> анализатором, позволяя достаточно гибко модифицировать 
  работу синтаксического и лексического анализаторов Лиспа.<br>
         <br>
         <b>Пакеты</b> представляют собой коллекции символов, работающих
в   пределах одного и того же пространства имен. Анализатор распознает принадлежность 
  символов путем сопоставления последовательностей букв, эти имена образующие, 
  с текущим пакетом.<br>
         <br>
         <b>Путевые имена</b> представляют собой имена файлов более или менее 
  независимым от реализации образом. Эти объекты используются для реализации 
  интерфейса с внешней файловой системой.<br>
         <br>
         <b>Потоки</b> представляют собой источники или приемники данных, 
обычно текста или байтов. Эти объекты используются для выполнения ввода/вывода, 
также как и для решения отдельных внутренних задач, таких как разбор строк.<br>
         <br>
         <b>Случайные ячейки</b> представляют собой структуры данных, в которых 
  сохраняется состояние встроенного генератора случайных чисел.<br>
         <br>
         <b>Структуры</b> представляют собой записи, определяемые пользователем, 
  которые являются объектами, имеющими именованные компоненты. Для ввода новых
  типов структур используется механизм <b>defstruct</b>. Некоторые реализации
  Common Lisp могут также использовать структуры для представления некоторых
  встроенных типов данных, таких как  <i>bignums</i>}, <i> readtables</i>
 ,           <i>streams</i>,  <i>hash tables</i>, и  <i>pathnames</i>, но 
этот   факт остается для<br>
     пользователя обычно незаметным.<br>
         <br>
         <b>Функции</b> являются объектами, которые могут вызываться как
процедуры;   они принимают аргументы и возвращают значения. Поскольку все
процедуры Лиспа   устроены так, что могут возвращать значения, то любая процедура
является  функцией. К числу этих функций относятся и <i> скомпилированные
функции</i>    , представляющие собой объекты, содержащие
      скомпилированный объектный код.  Некоторые функции представляются в виде списка, <b>car</b>
-часть которого  представляет собой определенный символ, а именно <b>lambda</b>
. Символы также  могут в определенных ситуациях ассоциироваться с функциями.<br>
         <br>
         <b>Сигналы</b> представляют собой объекты, предназначенные для управления 
  ходом выполнения программы в некоторых ситуациях путем формирования сигналов 
  и использования обработчиков, активируемых этими сигналами. В частности 
весь  механизм обработки ошибок построен на сигналах, которые
      формируются 
при выполнении тех или иных условий, и любая из этих ошибок может быть перехвачена 
 программой с помощью введения обработчика, настроенного на конкретные условия 
 ее возникновения.<br>
         <br>
         <b>Классы</b> определяют структуру и поведение других объектов,
которые   являются их  <i>экземплярами</i>. Любой объект данных Common Lisp
принадлежит   к тому или иному объекту данных. <br>
         <br>
         <b>Методы</b> представляют собой входящие в состав класс фрагменты 
  кода, которые выполняются с набором аргументов, который удовлетворяет определенному 
  шаблону. Методы не являются, как это можно было бы ожидать, функциями, они
  не могут вызываться непосредственно с набором аргументов, а лишь встраиваются 
  в обобщенные функции.<br>
         <br>
         <b>Обобщенные функции</b> являются разновидностью функций, которые, 
  наряду с другой информацией, содержат набор методов. При вызове обобщенной 
  функции выполняется некоторое подмножество содержащихся в ней методов. Подмножество,
  выбираемое для выполнения, определяется ее классом и составом переданных
 ей аргументов.<br>
         
            <h3>Возвращаясь к строительным кирпичикам</h3>
     Но давайте вернемся к самому началу. В общем то, для построения большинства 
  программ достаточно использовать только атомы и списки - все остальные типы
  являются, по большому счету производными от них. Поэтому давайте подробнее 
  рассмотрим именно эти два типа.<br>
            <br>
            <h4>Атомы</h4>
К атомам относятся числа, обсуждать которые смысла в общем -то нет и символы,
о которых речь пойдет ниже. Для проверки принадлежности некоторого объекта
к атомам используется предикат <b>atom, </b>который можно было бы определить
следующим образом (делать этого не надо, поскольку atom входит в состав любой
Лисп-системы - это одна из базовых функций):<br>
            <br>
            <!--mstheme--></font><pre><font color="#000000">(defun атом? &nbsp;(арг)</font></pre><!--mstheme--><font face="Times New Roman">
            <!--mstheme--></font><pre><font color="#000000">&nbsp; &nbsp; (or (numberp арг)</font></pre><!--mstheme--><font face="Times New Roman">
            <!--mstheme--></font><pre><font color="#000000">&nbsp; &nbsp; &nbsp; &nbsp; (symbolp &nbsp;арг))</font></pre><!--mstheme--><font face="Times New Roman">
            <!--mstheme--></font><pre><font color="#000000">)</font></pre><!--mstheme--><font face="Times New Roman">
Собственно говоря, с помощью подобного подхода вы можете легко определять
собственные, производные типы данных - ведь предикаты легко встраиваются
во многие служебные функции Лиспа. Но об этом как-нибудь в следующий раз,
а сейчас давайте посмотрим, как работает созданный нами предикат:<br>
            <br>
            <img src="article2/pic1.png" alt="Работа с предикатом атом?">
            <br>
            <br>
Как видите. работает наш предикат вполне предсказуемо. Я хочу лишь обратить
ваше внимание на ошибку, обнаруженную Лисп-системой при попытке проверить
принадлежность некоего объекта с именем <b>car</b>. Во-первых, вы видите,
что Лисп не делает различий между строчными и прописными буквами (это относится
только к именам объектов, записанных латиницей), а во-вторых, пытается интерпретировать
объект CAR как переменную (хотя в Лиспе имеется и встроенная функция с таким
же именем!). При этом Лисп полагает, что это имя переменной, тип <b>значения
            </b> которой необходимо определить. Но мы то такую переменную
не вводили, и Лисп с возмущением нам об этом сообщает...<br>
            <br>
А вот теперь начинается самое интересное! Обнаружив ошибку, Лисп переходит
а режим отладки, чтобы вы могли попытаться просмотреть содержимое переменных,
просмотреть протокол трассировки и т.д. Но достаточно часто причина ошибки
понятна и без дополнительной информации, и нам необходимо просто продолжить
работу. Проблема у начинающих лисповодов обычно состоит в том, что выйти
из этого режима не так-то просто. Чтобы вернуться в режим "нормальной" работы,
вам необходимо ввести с клавиатуры последовательность <b>:q - </b>так же,
как и в старом добром редакторе vi.<br>
            <br>
Теперь давайте подробнее поговорим о символах...<br>
         
            <h4>         </h4>
         
            <h4>Символы</h4>
 Символы представляют собой объекты Лиспа, которые используются сразу в нескольких
 целях и имеют ряд очень интересных характеристик. Но основное назначение 
символов - это использование их в качестве переменных для хранения атомов 
и любых других структур данных.<br>
 Каждый объект типа <b>symbol</b>  имеет имя, которое называется его  <i>
печатным именем</i>. Для любого заданного символа вы можете получить его
имя в форме строки. И наоборот, зная имя символа, мы можем, введя это имя
в виде строки, получить в сам символ.<br>
         <br>
         
            <blockquote>           
              <blockquote>             
                <blockquote><small>Забегая вперед, отметим, что символы не
свалены в одну беспорядочную кучу, а распределены по
                  <i>пакетам</i>
 , в каждом из которых имя символа уникально. Но об этом мы поговорим отдельно.<br>
 </small></blockquote>
               </blockquote>
               </blockquote>
               <br>
  Символы имеют компонент, называемый <i>списком свойств</i>, который также
 обозначается как <b>plist</b>. Традиционно этот компонент
      всегда представляет
 собой список, в котором элементы с четными номерами (включая первый элемент,
 который имеет номер 0) являются символами --- именами свойств, а следующие
 за ними элементы --- значения этих свойств. Для манипулирования списком
свойств  реализованы специальные функции, которые фактически, позволяют интерпретировать
               <b>любой </b>символ как расширяемую структуру данных.<br>
               <br>
  Кроме того, символы используются для представления определенных видов переменных
 Лисп-программ, для чего разработаны также специальные функции.<br>
               <br>
  Как уже указывалось выше, для обращения к символу достаточно  указать его
 имя. Если это имя отлично от пустой строки, и если имя состоит только из
прописных букв, цифр или определенных псевдоалфавитных специальных знаков
(К которым не относятся скобки и пробел) и если имя этого символа не может
быть случайно перепутано с числом, то для обращения к символу достаточно
указания последовательности букв, образующих его имя. Любые прописные буквы,
которые используются для представления внутреннего имени символа в тексте
программы могут быть записаны в любом регистре. Более подробно мы поговорим
об этом ниже.<br>
  Например:<br>
               <!--mstheme--></font><pre><font color="#000000">FROBBOZ                ; Имя этого символа - FROBBOZ</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">frobboz                ; Другое упоминание того же символа</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">fRObBoz                ; И это все о нем...</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">unwind-protect         ; Символ, содержащий в имени букву -</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">+\$                    ; Символ с именем +\$</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">1+                     ; Символ с именем 1+</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">+1                     ; А это число 1, а вовсе не символ!</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">pascal_style           ; Имя символа содержит знак подчеркивания</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">b^2-4*a*c              ; Все это один символ!</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">                       ; В имени содержится несколько специальных букв</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">file.rel.43            ; А в этом имени символа есть точки</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">/usr/games/zork        ; Этот символ содержит в имени ``косые''</font></pre><!--mstheme--><font face="Times New Roman">
               <!--mstheme--></font><pre><font color="#000000">
</font></pre><!--mstheme--><font face="Times New Roman">
                Традиционно, наряду с буквами алфавита и цифрами в качестве
 элементов имен могут использоваться следующие специальные буквы и<br>
  знаки:<br>
  <br>
      <font color="#000000">
  +  -  *  /  @  $  %  ^  &amp;  _  =  &lt;  &gt;  ~  .<br>
      </font>
  <br>
               <br>
  Некоторые из этих букв используются вполне традиционным образом; например, 
символы, которые обозначают специальные переменные, обычно имеют имена, начинающиеся 
и заканчивающиеся звездочкой -  <b>*</b>. Последняя из перечисленных выше 
букв - точка, рассматривается как буква алфавита, что не позволяет создать 
имя, состоящее только из точек. Допускается использование только отдельной 
точки при описании точечных списков и cons-ячеек, но две точки подряд рассматриваются 
как ошибка. <br>
               <br>
  Печатное имя символа может состоять из прописных, строчных букв или их
смеси. что касается латинских букв, то Common Lisp при считывании обычно
конвертирует входной поток в прописные буквы. Это приводит к тому, что символы,
записанные латиницей к регистру нечувствительны. С кириллицей дел обстоит
иначе. Поскольку, с точки зрения Лиспа, вторая половина 8-битной кодовой
таблицы букв не содержит, то и преобразовывать
      из строчных букв в прописные
там нечего. Поэтому, вы можете именовать свои символы и кириллицей --- еще
раз замечу, что писать программы на русском языке очень приятно и удобно,
но должны иметь в виду, что в отличие от традиционного подхода такие имена
чувствительны к регистру букв.<br>
               <br>
  <br>
               
                  <blockquote>                 
                    <blockquote><small> В некоторых версиях Common Lisp для
преодоления описанного выше ограничения предусмотрена специальная функция
                      <b> readtable-case</b>
, управляющая процессом преобразования регистров букв при вводе модулем
                      <b>
read</b>. Однако GNU Common Lisp к их числу не относится.</small><br>
                   </blockquote>
                   </blockquote>
  <br>
 Еще раз отметим, что символы используются в Лиспе для унифицированного представления 
переменных любых типов. Фактически любому символу может быть присвоено значение 
любого из рассмотренных выше типов и в любой момент тип значения может быть 
изменен. В некотором отношении эта вакханалия подобна концепции старого доброго
      Basic, но в отличие от него вы в любой момент можете проконтролировать тип 
данных объекта, связанного с тем или иным символом. <br>
                   <br>
                   
                      <h4>Списки и cons-ячейки</h4>
             Cons ячейка представляет собой запись, состоящую из двух компонентов,
  которые по традиции называются  <b>car</b> и <b>cdr</b>. Обычно эти записи
  используются для представления списков.<br>
                   <br>
                   <i>Список</i> представляет собой рекурсивную структуру 
данных, которая  является либо пустым списком, либо cons-ячейку, cdr-частью 
которой является  список. Поэтому список может интерпретироваться как цепочка 
cons-ячеек, связанных  через их <b>cdr</b>-компоненты, и заканчивается символом
      NIL, соответствующему  пустому списку. Компоненты  <i>car</i>  этих cons-ячеек
 называются  <i>элементами</i>    списка. Каждому элементу списка соответствует
 некоторая cons-ячейка. Пустой  список не содержит ни одного элемента.<br>
                   <br>
    Список может быть представлен путем последовательного перечисления элементов
  списка, разделенных пробелом, табулятором<br>
    или переводом строки, и заключенные в скобки. <br>
                   <br>
                   <br>
                   <!--mstheme--></font><pre><font color="#000000">(a b c)                ; Список из трех символов </font></pre><!--mstheme--><font face="Times New Roman">
                   <!--mstheme--></font><pre><font color="#000000">(2.0s0 (a 1) \#\*)     ; Список из трех объектов: короткого числа </font></pre><!--mstheme--><font face="Times New Roman">
                   <!--mstheme--></font><pre><font color="#000000">                       ; с плавающей запятой, другого списка и буквы</font></pre><!--mstheme--><font face="Times New Roman">
                   <br>
                   <br>
    Поэтому пустой список NIL может быть представлен как <b>'()</b>, поскольку
  представляет собой список без элементов.<br>
                   <br>
                   <b>Точечный список</b> представляет собой вариант списка, 
в котором  последняя cons-ячейка в cdr-части содержит не
      NIL, а некоторый 
другой объект,  отличный от cons-ячейки. Название этого списка связано со 
специальной нотацией,  принятой для его записи: элементы списка, как обычно, 
заключены в скобки,  но последний элемент отделяется от предпоследнего не 
пробелом или иным разделителем,  а точкой. В предельном случае так же может 
быть записана и ``отдельно стоящая''  cons-ячейка, в которой  car- и  cdr-части 
заключены в скобки и разделены точкой, окруженной пробелами. Например:<br>
                   <br>
                   <!--mstheme--></font><pre><font color="#000000">(a . 4          ; cons-ячейка, car-часть которой является символом,</font></pre><!--mstheme--><font face="Times New Roman">
                   <!--mstheme--></font><pre><font color="#000000">                ; а  cdr-часть - целое число</font></pre><!--mstheme--><font face="Times New Roman">
                   <!--mstheme--></font><pre><font color="#000000">(a b c . d)     ; Точечный список с тремя элементами, последняя</font></pre><!--mstheme--><font face="Times New Roman">
                   <!--mstheme--></font><pre><font color="#000000">                ; cons-ячека содержит в  cdr-части d </font></pre><!--mstheme--><font face="Times New Roman">
                   <br>
    Допускается использовать запись вида <b>(a b . (c d))</b>, которая обозначает
  то же самое, что и <b>(a b c d)</b>. В стандартных программах вывода Лиспа
  первый формат вывода не используется, но это не мешает вам баловаться ``нестандартным
  представлением''.<br>
                   <br>
    В литературе (к сожалению, преимущественно иностранной, поскольку на
русском   языке о Лиспе пишут мало) довольно часто термин <b> list</b> используется
  как по отношению к обычным, так и к точечным спискам. В тех случаях, когда
  различие между этими типами списков имеет значение, мы будем использовать
  название ``обычные списки'' по отношению к спискам, заканчивающимся символом
      NIL. Большинство функций, работающих со списками, ориентированы именно
на   такие, обычные списки. Поэтому использовать в этих функциях вместо обычных
  точечные списки как правило не допускается.<br>
                   <br>
                   
                      <blockquote>                     
                        <blockquote><small>Со стороны международного комитета 
по стандартизации  рекомендуется использовать для проверки достижения конца
 списка предикат             <b>endp</b> или его эквивалент. Как правило,
эта функция сигнализирует  об ошибке, если обнаруженный список заканчивается
атомом, отличным от NIL. На самом деле такая экстремистская реакция вовсе
не обязательна, поскольку в Лиспе нередко используются циклические списки.
В таких ситуациях для проверки  достижения конца списка удобнее использовать
предикат <b>atom</b> , который  воспимет как признак конца списка любой атом,
который может быть и не равен nil.</small><br>
                       </blockquote>
                       </blockquote>
   В ряде случаев по отношению к некоторым cons-ячейкам используется термин
                   <i>  дерево</i>, если эти ячейки доступны в результате
последовательного применения  car и  cdr преобразований  (см. ниже) исходной
структуры данных. При этом элементы структуры, отличные от cons-ячеек (то
есть такие, к которым нельзя применить функции car и cdr называются  <i>листьями</i>
  дерева.<br>
                       <br>
    Списки, точечные списки и деревья не являются взаимоисключающими типами 
 данных. Это просто несколько способов взглянуть на одну и<br>
    ту же структуру данных. В качестве примера еще одного альтернативного 
подхода  можно упомянуть  <i>ассоциативные списки</i>. Еще раз подчеркну, 
что ни один  из этих терминов не обозначает реальный тип данных в Лиспе. К
базовому типу  данных относятся только cons-ячейки, а также
      nil, который является
единственным  объектом, принадлежащему типу <b>null</b>. Тип данных Лиспа
 <b>list</b> обозначает только объединение объектов типов<br>
                       <b>cons</b> и <b>null</b>, и лишь с этой точки зрения 
к нему могут быть отнесены как обычные, так и точечные списки. <br>
                       <br>
                          <br>
                          <h3>Работа со списками</h3>
Понятно, что поскольку списки являются основной "составной" структурой данных,
то большая часть функций Лиспа работает именно со списками. Но как ни удивительно,
все многообразие функций языка основано на трех китах - трех основных функциях
с помощью которых можно реализовать все остальные. Вот эти киты - <b>CAR,
CDR </b>и <b>CONS.</b><br>
                          <br>
                          <h4>CAR</h4>
Функция CAR предназначена для извлечения первого элемента списка, который
возвращается в качестве ее результата. Например,<br>
                          <br>
      <font color="#000000">(car '(1 2 3 4 5))<br>
      </font>
                          <br>
вернет 1, а<br>
                          <br>
      <font color="#000000">(car '((1 2 3) (4 5) 6))<br>
      </font>
                          <br>
вернет список - (1 2 3).<br>
                          <br>
                          <h4>CDR</h4>
CDR выполняет "оставшуюся" часть работы - эта функция возвращает <b>список</b>
, содержащий все элементы кроме первого. Поэтому, применительно к приведенным
выше примерам, вы получите:<br>
                          <br>
      <font color="#000000">(cdr '(1 2 3 4 5))<br>
      <br>
      </font>(2 3 4 5)<br>
      <font color="#000000"><br>
      (cdr '((1 2 3) (4
5) 6))<br>
      <br>
      </font>((4 5) 6)<br>
      <br>
Как вы увидите ниже, из этих строительных кирпичиков можно построить действительно
интересные конструкции!<br>
                          <br>
                          <h4>CONS</h4>
Приведенные выше функции используются для разбиения списка на отдельные фрагменты.
А функция CONS, наоборот, производит слияние двух аргументов, формируя из
них список, который возвращается в качестве результата.  Функция принимает
ровно 2 (!) аргумента, первый из которых используется в качестве CAR-части
списка, а второй - в качестве его CDR-части. Это очень важно - первый аргумент
рассматривается функцией cons именно как элемент вновь формируемого списка
(см. рис.2)<br>
                          <br>
                          <img src="article2/pic2.png" alt="Работа функции cons">
                          <br>
                          <br>
                          <br>
                          <h4> Производные функции</h4>
Теория утверждает (и подтверждается практикой), что для выполнения любых
операций со списками достаточно рассмотренных
      выше функций. Но конечно же,
использовать только их не слишком удобно. Достаточно часто возникает необходимость
извлечь второй, третий или четвертый элемент списка, либо получить CDR-часть
первого элемента списка. Конечно же для решения этих задач программисты разрабатывали
специальные функции. Например, для извлечения второго элемента списка можно
использовать<br>
                          <br>
      <font color="#000000">(defun cadr (арг)<br>
   (car (cdr арг))<br>
)<br>
      </font>
                          <br>
Хитрость состоит в том, что подобные функции определять вам не нужно - они
входят в состав языка уже лет двадцать пять, как минимум. Более того, их
имена стандартизованы, что позволяет их даже не запоминать. Взгляните, например,
на приведенное выше определение - выполнение функции осуществляется "справа-налево"
- вначале мы выполняем операцию cdr, а потом car к полученному результату.
Название функции "проглатывает" конечные и начальные буквы последовательно
применяемых функций, в результате чего мы получаем
      cadr. Аналогичным образом
в Common Lisp реализовано десятка два функций, которые позволяют извлечь
любой элемент или фрагмент списка глубиной до 4 степеней вложенности. Кроме
того, имеется еще одна полезная функция:<br>
                          <br>
      <font color="#000000">
(<b>nth</b> i список)<br>
      </font>
                          <br>
которая возвращает i-й элемент списка (отсчет начинается с нуля). Фактически,
с использованием этой функции списки могут интерпретироваться как одномерные
массивы.<br>
                          <br>
                          <br>
На этом давайте закончим теоретическую часть урока и перейдем к практическому
примеру. Когда-то, во время учебы в физико-математической школе N145 г. Киева
я столкнулся с тем, что каждый преподаватель, будь то биология или география,
искренне полагал, что именно его предмет является самым важным, и именно
на него надо обращать особое внимание. Английский язык не был исключением,
и неправильные глаголы нужно было знать наизусть... Поэтому в память о тех
деньках я хочу предложить вашему вниманию программу, которая будет анализировать
английский глагол в произвольной форме и возвращать его инфинитив. Для тех
кто не владеет языком поясню, что как правило, в английском языке глагольные
формы образуются приставкой суффикса &quot;s&quot; или
      &quot;es&quot; для третьего лица настоящего
времени (в нашей программе для упрощения не рассматривается) или 
      суффикса &quot;ed&quot; для форм прошедшего времени. Но дело в том, что в языке имеется также
несколько десятков глаголов, которые этому правилу не подчиняются - для них
используются специальные формы прошедшего времени. Эти то глаголы и называются
неправильными. При построении систем автоматического анализ текстов на естественном
языке чаще всего тонкости представления времен особой роли не играют, и нам
достаточно использовать инфинитивную форму глагола. Поэтому мы определим
функцию, которая и будет решать эту задачу. <br>
                          <br>
                          <br>
Конечно, это не одна единственная функция, а набор, который выглядит следующим
образом:<br>
                          <br>
      <font color="#000000">;;;<br>;;; Программа приведения
      глагольных форм английского языка<br>;;; к
      инфинитиву<br>;;;<br>;;; (С) В.Водолазкий,&nbsp;
      2002,&nbsp;&nbsp; http://come.to/vodolaz<br>;;;<br><br>(setq плохие-глаголы<br>&nbsp;&nbsp;
      '(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&quot;be&quot;
      (&quot;was&quot; &quot;were&quot;) &quot;been&quot;&nbsp; &quot;быть&quot;)<br>
      (&quot;become&quot; &quot;became&quot; &quot;become&quot; &quot;стать&quot;)<br>
      (&quot;begin&quot; &quot;began&quot; &quot;begun&quot; &quot;начать&quot;)<br>
      (&quot;blow&quot; &quot;blew&quot; &quot;blown&quot; &quot;дуть&quot;)<br>
      (&quot;break&quot; &quot;broke&quot; &quot;broken&quot; &quot;ломать&quot;)<br>
      (&quot;bring&quot; &quot;brought&quot; &quot;brought&quot; &quot;приносить&quot;)<br>
      (&quot;build&quot; &quot;built&quot; &quot;built&quot; &quot;строить&quot;)<br>
      (&quot;buy&quot; &quot;bought&quot; &quot;bought&quot; &quot;покупать&quot;)<br>
      (&quot;catch&quot; &quot;caught&quot; &quot;caught&quot; &quot;ловить&quot;)<br>
      (&quot;choose&quot; &quot;chose&quot; &quot;chosen&quot; &quot;выбирать&quot;)<br>
      (&quot;come&quot; &quot;came&quot; &quot;come&quot; &quot;приходить&quot;)<br>
      (&quot;cost&quot; &quot;cost&quot; &quot;cost&quot; &quot;стоить&quot;)<br>
      (&quot;cut&quot; &quot;cut&quot; &quot;cut&quot; &quot;резать&quot;)<br>
      (&quot;do&quot;&nbsp;&nbsp; &quot;did&quot; &quot;done&quot; &quot;делать&quot;)<br>
      (&quot;draw&quot; &quot;drew&quot; &quot;drawn&quot; &quot;рисовать&quot;)<br>
      (&quot;drink&quot;&nbsp; &quot;drank&quot; &quot;drunk&quot; &quot;пить&quot;)<br>
      (&quot;drive&quot; &quot;drove&quot; &quot;driven&quot; &quot;водить&quot;)<br>
      (&quot;eat&quot; &quot;ate&quot; &quot;eaten&quot; &quot;есть&quot;)<br>
      (&quot;fall&quot; &quot;fell&quot; &quot;fallen&quot; &quot;падать&quot;)<br>
      (&quot;feel&quot; &quot;felt&quot; &quot;felt&quot; &quot;чувствовать&quot;)<br>
      (&quot;fight&quot; &quot;fought&quot; &quot;fought&quot; &quot;бороться&quot;)<br>
      (&quot;find&quot; &quot;found&quot; &quot;found&quot; &quot;находить&quot;)<br>
      (&quot;fly&quot; &quot;flew&quot; &quot;flown&quot; &quot;летать&quot;)<br>
      (&quot;forget&quot; &quot;forgot&quot; &quot;forgotten&quot; &quot;забывать&quot;)<br>
      (&quot;forgive&quot; &quot;forgave&quot; &quot;forgiven&quot; &quot;прощать&quot;)<br>
      (&quot;get&quot; &quot;got&quot; &quot;got&quot; &quot;получать&quot;)<br>
      (&quot;give&quot; &quot;gave&quot; &quot;given&quot; &quot;давать&quot;)<br>
      (&quot;go&quot; &quot;went&quot; &quot;gone&quot; &quot;идти&quot;)<br>
      (&quot;grow&quot; &quot;grew&quot; &quot;grown&quot; &quot;расти&quot;)<br>
      (&quot;have&quot; &quot;had&quot; &quot;had&quot; &quot;иметь&quot;)<br>
      (&quot;hear&quot; &quot;heard&quot; &quot;heard&quot; &quot;слышать&quot;)<br>
      (&quot;hide&quot; &quot;hid&quot; &quot;hidden&quot; &quot;прятать&quot;)<br>
      (&quot;hold&quot; &quot;held&quot; &quot;held&quot; &quot;держать&quot;)<br>
      (&quot;keep&quot; &quot;kept&quot; &quot;kept&quot; &quot;хранить&quot;)<br>
      (&quot;know&quot; &quot;knew&quot; &quot;known&quot; &quot;знать&quot;)<br>
      (&quot;leave&quot; &quot;left&quot; &quot;left&quot; &quot;оставлять&quot;)<br>
      (&quot;lend&quot; &quot;lent&quot; &quot;lent&quot; &quot;одалживать&quot;)<br>
      (&quot;let&quot; &quot;let&quot; &quot;let&quot; &quot;разрешать&quot;)<br>
      (&quot;lose&quot; &quot;lost&quot; &quot;lost&quot; &quot;терять&quot;)<br>
      (&quot;make&quot; &quot;made&quot; &quot;made&quot; &quot;делать&quot;)<br>
      (&quot;mean&quot; &quot;meant&quot; &quot;meant&quot; &quot;означать&quot;)<br>
      (&quot;meet&quot; &quot;met&quot; &quot;met&quot; &quot;встречать&quot;)<br>
      (&quot;pay&quot; &quot;paid&quot; &quot;paid&quot; &quot;платить&quot;)<br>
      (&quot;put&quot; &quot;put&quot; &quot;put&quot; &quot;класть&quot;)<br>
      (&quot;read&quot; &quot;read&quot; &quot;read&quot; &quot;читать&quot;)<br>
      (&quot;ring&quot; &quot;rang&quot; &quot;rung&quot; &quot;звонить&quot;)<br>
      (&quot;rise&quot; &quot;rose&quot; &quot;risen&quot; &quot;подниматься&quot;)<br>
      (&quot;run&quot; &quot;ran&quot; &quot;run&quot; &quot;бежать&quot;)<br>
      (&quot;say&quot; &quot;said&quot; &quot;said&quot; &quot;говорить&quot;)<br>
      (&quot;see&quot; &quot;saw&quot; &quot;seen&quot; &quot;видеть&quot;)<br>
      (&quot;sell&quot; &quot;sold&quot; &quot;sold&quot; &quot;продавать&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (&quot;send&quot; &quot;sent&quot; &quot;sent&quot; &quot;посылать&quot;)<br>
      (&quot;shake&quot; &quot;shook&quot; &quot;shaken&quot; &quot;трясти&quot;)<br>
      (&quot;shine&quot; &quot;shone&quot; &quot;shone&quot; &quot;сиять&quot;)<br>
      (&quot;show&quot; &quot;showed&quot; &quot;shown&quot; &quot;показывать&quot;)<br>
      (&quot;shut&quot; &quot;shut&quot; &quot;shut&quot; &quot;закрывать&quot;)<br>
      (&quot;sing&quot; &quot;sang&quot; &quot;sung&quot; &quot;петь&quot;)<br>
      (&quot;sit&quot; &quot;sat&quot; &quot;sat&quot; &quot;сидеть&quot;)<br>
      (&quot;sleep&quot; &quot;slept&quot; &quot;slept&quot; &quot;спать&quot;)<br>
      (&quot;speak&quot; &quot;spoke&quot; &quot;spoken&quot; &quot;говорить&quot;)<br>
      (&quot;spend&quot; &quot;spent&quot; &quot;spent&quot; &quot;тратить&quot;)<br>
      (&quot;stand&quot; &quot;stood&quot; &quot;stood&quot; &quot;стоять&quot;)<br>
      (&quot;stick&quot; &quot;stuck&quot; &quot;stuck&quot; &quot;клеить&quot;)<br>
      (&quot;swim&quot; &quot;swam&quot; &quot;swum&quot; &quot;плавать&quot;)<br>
      (&quot;take&quot; &quot;took&quot; &quot;taken&quot; &quot;брать&quot;)<br>
      (&quot;teach&quot; &quot;taught&quot; &quot;taught&quot; &quot;учить&quot;)<br>
      (&quot;tell&quot; &quot;told&quot; &quot;told&quot; &quot;рассказывать&quot;)<br>
      (&quot;think&quot; &quot;thought&quot; &quot;thought&quot; &quot;думать&quot;)<br>
      (&quot;wake&quot; &quot;woke&quot; &quot;woken&quot; &quot;будить&quot;)<br>
      (&quot;wear&quot; &quot;wore&quot; &quot;worn&quot; &quot;носить&quot;)<br>
      (&quot;win&quot; &quot;won&quot; &quot;won&quot; &quot;побеждать&quot;)<br>
      (&quot;write&quot; &quot;wrote&quot; &quot;written&quot; &quot;писать&quot;)<br>&nbsp;&nbsp;
      )<br>)<br><br>;;<br>;; Функции просмотра
      содержимого списка плохих глаголов<br>;; и
      выделения инфинитивной формы<br>;;<br><br>(defun
      просмотр-плохих (глагол список)<br>;
      формируем временную переменную<br>(setq
      формы (car список))<br>; (prin1 глагол)(princ &quot; -
      &quot;)(prin1 формы)(terpri)<br>(cond&nbsp;<br>&nbsp; ((equal
      глагол (car формы)) глагол)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ; это 1 форма<br>&nbsp; ((equal глагол (caddr формы)) (car
      формы)) ; это 3-я форма<br>&nbsp; ((equal глагол (cadr
      формы)) (car формы))&nbsp; ; это 2-я форма&nbsp;<br>&nbsp;
      ; особый случай - раздвоенная форма was-were<br>&nbsp;
      ((listp (cadr формы))&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; (cond<br>&nbsp;&nbsp;&nbsp;&nbsp;
      ((equal глагол (car (cadr формы))) (car формы))<br>&nbsp;&nbsp;&nbsp;&nbsp;
      ((equal глагол (cadr (cadr формы))) (car формы))<br>&nbsp;&nbsp;&nbsp;&nbsp;
      ((&gt; (length список) 0 ) (просмотр-плохих
      глагол (cdr список)))<br>&nbsp;&nbsp;&nbsp;&nbsp; )<br>&nbsp;&nbsp;&nbsp;
      )&nbsp;<br>&nbsp; ; список просмотрен, глагол не
      найден<br>&nbsp; ;рекурсивный просмотр всего
      списка<br>&nbsp; ((&gt; (length список) 0 ) (просмотр-плохих
      глагол (cdr список)))<br>&nbsp; (t break)<br>)<br>)<br><br><br>(defun
      плохой? (глагол)<br>&quot;Функция
      последовательно просматривает все
      содержимое<br>&nbsp;структуры плохие-глаголы
      и возвращает инфинитивную форму<br>&nbsp;если
      глагол оказался плохим или nil, если такой
      формы в<br>&nbsp;таблице не оказалось. Может
      использоваться как автономный предикат.&quot;<br>&nbsp;<br>&nbsp;(просмотр-плохих
      глагол плохие-глаголы)<br>)<br><br>;;<br>;; в
      случае правильного глагола отрезаем ему
      суффикс ed<br>;;<br><br>(defun отрезать-суффикс (строка)<br>&nbsp;
      &quot;Функция отрезает суфикс для
      глагольной формы, преобразуя<br>&nbsp;&nbsp;
      правильный глагол в инфинитив&quot;<br>&nbsp;&nbsp;
      ; простейшее решение&nbsp;<br>&nbsp;&nbsp; (string-right-trim
      &quot;ed&quot; строка)&nbsp;&nbsp;<br>)<br><br>;;<br>;;
      выделение инфинитива, если глагольная
      форма не найдена,<br>;; возвращает
      исходный глагол с &quot;отрезанным&quot;
      суффиксом ed<br>;;<br>(defun инфинитив (глагол)<br>&nbsp;
      (if (setq результат (плохой? глагол))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      результат<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (отрезать-суффикс
      глагол)<br>&nbsp; )<br>)<br></font>
      <p>
Вначале мы определяем список <b>плохие-глаголы, </b>каждый элемент которого
представляет собой также список, содержащий инфинитивную форму неправильного
глагола, а затем его вторую и третью формы. Завершает список русский перевод
глагола (в программе пока не используется).<br>
Чтобы решить задачу нам необходимо понять, с каким глаголом мы имеем дело
- с правильным или неправильным. Поэтому мы определяем предикат <b>плохой?</b>
, который возвращает инфинитивную форму глагола, если он оказался неправильным
(интерпретируется системой как T) или NIL, если такого глагола в списке нет
(а следовательно, это правильный глагол). <br>
                          <br>
Обратите внимание на построение функции <b>инфинитив. </b>Проверяя аргумент
                          <b>глагол </b>на принадлежность к числу неправильных,
мы помещаем результат проверки в переменную <b>результат. </b>Если ее значение
отлично от NIL, то и значение функции <b>setq </b>также будет отлично от
      NIL. В этом случае функция <b>if </b>вернет в качестве значения переменную
                          <b>результат.</b> Если же переменная <b>результат
                          </b>равна NIL, функция if выполнит оценку следующей
формы (ветка else) - и попросту отрежет суффикс у глагола (впрочем, стоит
ли повторять текст программы теми же словами :-)).<br>
                          <br>
Для проверки работы функции можно выполнить несколько запросов:<br>
                          <br>
                          <!--mstheme--></font><pre><font color="#000000">(princ &quot;shown -&gt; &quot;)
(prin1 (инфинитив &quot;shown&quot;))(terpri)
(princ &quot;rose -&gt; &quot;)
(prin1 (инфинитив &quot;rose&quot;))(terpri)
(princ &quot;walked -&gt; &quot;)
(prin1 (инфинитив &quot;walked&quot;))(terpri)
</font></pre><!--mstheme--><font face="Times New Roman">
                          <br>
В результате вы должны получить следующее:<br>
                          <br>
                          <!--mstheme--></font><pre><font color="#000000">shown -&gt; show</font></pre><!--mstheme--><font face="Times New Roman">
                          <!--mstheme--></font><pre><font color="#000000">rose &nbsp;-&gt; rise</font></pre><!--mstheme--><font face="Times New Roman">
                          <!--mstheme--></font><pre><font color="#000000">walked -&gt; walk</font></pre><!--mstheme--><font face="Times New Roman">
                          <br>
Теперь давайте поговорим о домашнем задании. Во-первых, имеет смысл дополнить
функцию получения инфинитива обработкой форм настоящего времени - отрезанием
суффикса s или es. Во-вторых, имеет смысл использовать русский перевод глагола
и написать функцию, которая возвращает русское значение слова. Но в этом
случае вам нужно придумать самостоятельно, как быть с правильными глаголами
- ведь для них словаря пока не предусмотрено. Дерзайте, пишите - лучшие решения
будут опубликованы.<br>
                          <br>
 <br>
                       </div>


      <p> &nbsp; </p>
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>



      <p> &nbsp; </p>
&nbsp;
<!-- SpyLOG f:0211 -->
<script language="javascript"><!--
Mu="u4689.42.spylog.com";Md=document;Mnv=navigator;Mp=1;
Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();
Mt=(new Date()).getTimezoneOffset();
Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;
My="";
My+="<a href='http://"+Mu+"/cnt?cid=468942&f=3&p="+Mp+"&rn="+Mrn+"' target='_blank'>";
My+="<img src='http://"+Mu+"/cnt?cid=468942&"+Mz+"&r="+escape(Md.referrer)+"&pg="+escape(window.location.href)+"' border=0  width=88 height=31  alt='SpyLOG'>";
My+="</a>";Md.write(My);//--></script><noscript>
<a href="http://u4689.42.spylog.com/cnt?cid=468942&f=3&p=1" target="_blank">
<img src="http://u4689.42.spylog.com/cnt?cid=468942&p=1" alt='SpyLOG' border='0'  width=88 height=31 >
</a></noscript>
<!-- SpyLOG  --><!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p>
<script type="text/javascript"><!--
var yandex_r = Math.round(Math.random() * 100000);
document.write('<sc'+'ript type="text/javascript" src="http://an.yandex.ru/code/14812?rnd=' + yandex_r + '&direct-style=2&direct-limit=4&market-style=0&market-limit=4"></'+'sc'+'ript>');
//--></script>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h5>Послать письмо <a href="mailto:voldemarus@narod.ru">
voldemarus@narod.ru</a> &nbsp;<br>
Авторские права © 2003-2009
Картонная армия<br>
Последнее изменение:
января 09, 2010</h5>
<p></p>
<p></p>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>


