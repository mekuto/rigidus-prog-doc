
<!-- saved from url=(0102)https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="./LISP History_files/analytics.js" charset="utf-8"></script>

<script type="text/javascript">archive_analytics.values.service='wb';archive_analytics.values.server_name='wwwb-app41.us.archive.org';archive_analytics.values.server_ms=1415;</script><script type="text/javascript" src="./LISP History_files/wbhack.js" charset="utf-8"></script>

<script type="text/javascript">
__wbhack.init('https://web.archive.org/web');
</script>
<link rel="stylesheet" type="text/css" href="./LISP History_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./LISP History_files/iconochive.css">

<!-- End Wayback Rewrite JS Include -->
<title>LISP History</title>
</head><body><div id="wm-ipp" lang="en" style="display: block; direction: ltr;">
<div style="position:fixed;left:0;top:0;right:0;">
<div id="wm-ipp-inside">
  <div style="position:relative;">
    <div id="wm-logo" style="float:left;width:130px;padding-top:10px;">
      <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./LISP History_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
    </div>
    <div class="r" style="float:right;">
      <div id="wm-btns" style="text-align:right;height:25px;">
                  <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html#" onclick="__wm.saveSnapshot(&#39;http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html&#39;, &#39;20061029131004&#39;)" title="Save to My Web Archive" id="wm-save-snapshot-open">
            <span class="iconochive-web"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web"></span>
        	<a href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
	<a id="wm-tb-close" href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html#close" onclick="__wm.h(event);return false;" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share" style="text-align:right;">
	<a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html#" onclick="window.open(&#39;https://www.facebook.com/sharer/sharer.php?u=https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de:80/html/lisp/mcc91.html&#39;, &#39;&#39;, &#39;height=400,width=600&#39;); return false;" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
	<a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html#" onclick="window.open(&#39;https://twitter.com/intent/tweet?text=https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de:80/html/lisp/mcc91.html&amp;via=internetarchive&#39;, &#39;&#39;, &#39;height=400,width=600&#39;); return false;" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
    </div>
    <table class="c" style="">
      <tbody>
	<tr>
	  <td class="u" colspan="2">
	    <form target="_top" method="get" action="https://web.archive.org/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html" onfocus="this.focus();this.select();" autocomplete="off"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20061029131004"><input type="submit" value="Go"></form>
	  </td>
	  <td class="n" rowspan="2" style="width:110px;">
	    <table>
	      <tbody>
		<!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
		<tr class="m">
		  <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20041209025920/http://www8.informatik.uni-erlangen.de:80/html/lisp/mcc91.html" title="09 Dec 2004"><strong>Dec</strong></a></td>
		  <td class="c" id="displayMonthEl" title="You are here: 13:10:04 Oct 29, 2006">OCT</td>
		  <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20160304025804/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html" title="04 Mar 2016"><strong>Mar</strong></a></td>
		</tr>
		<!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
		<tr class="d">
		  <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20041209025920/http://www8.informatik.uni-erlangen.de:80/html/lisp/mcc91.html" title="02:59:20 Dec 09, 2004"><img src="./LISP History_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a></td>
		  <td class="c" id="displayDayEl" style="width:34px;font-size:24px;white-space:nowrap;" title="You are here: 13:10:04 Oct 29, 2006">29</td>
		  <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20160304025804/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html" title="02:58:04 Mar 04, 2016"><img src="./LISP History_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a></td>
		</tr>
		<!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
		<tr class="y">
		  <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20041209025920/http://www8.informatik.uni-erlangen.de:80/html/lisp/mcc91.html" title="09 Dec 2004"><strong>2004</strong></a></td>
		  <td class="c" id="displayYearEl" title="You are here: 13:10:04 Oct 29, 2006">2006</td>
		  <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20160304025804/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html" title="04 Mar 2016"><strong>2016</strong></a></td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td class="s">
	    	    <div id="wm-nav-captures"><a class="t" href="https://web.archive.org/web/*/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html" title="See a list of every capture for this URL">29 captures</a><div class="r" title="Timespan for captures of this URL">4 Jul 1997 - 28 Mar 2017</div></div>
	  </td>
	  <td class="k">
	    <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html" id="wm-graph-anchor">
	      <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
		<canvas id="wm-sparkline-canvas" width="550" height="27" border="0"></canvas>
	      <div class="yt" style="display: none; width: 25px; height: 27px;"></div><div class="mt" style="display: none; width: 2px; height: 27px;"></div></div>
	    </a>
	  </td>
	</tr>
      </tbody>
    </table>
    <div style="position:absolute;bottom:0;right:2px;text-align:right;">
      <a id="wm-expand" class="wm-btn wm-closed" href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html#expand" onclick="__wm.ex(event);return false;"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span style="font-size:80%">About this capture</span></a>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
            <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
            <div style="display:inline-block;vertical-align:top;width:50%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/alexacrawls);"></span>
		Organization: <a style="color:#33f;" href="https://archive.org/details/alexacrawls" target="_new"><span class="wm-title">Alexa Crawls</span></a>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  Starting in 1996, <a href="http://www.alexa.com/">Alexa Internet</a> has been donating their crawl data to the Internet Archive.  Flowing in every day, these data are added to the <a href="http://web.archive.org/">Wayback Machine</a> after an embargo period.
	</div>
	      </div>
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/32_crawl)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/32_crawl" target="_new"><span class="wm-title">32_crawl</span></a></div>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  this data is currently not publicly accessible.
	</div>
	      </div>
    </div>
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img src="./LISP History_files/loading.gif" alt="loading"></div>
    </div>
  </div></div></div></div><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./LISP History_files/timestamp.js" charset="utf-8"></script>
<script type="text/javascript" src="./LISP History_files/graph-calc.js" charset="utf-8"></script>
<script type="text/javascript" src="./LISP History_files/auto-complete.js" charset="utf-8"></script>
<script type="text/javascript" src="./LISP History_files/toolbar.js" charset="utf-8"></script>

<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
.wb-autocomplete-suggestions {
    text-align: left; cursor: default; border: 1px solid #ccc; border-top: 0; background: #fff; box-shadow: -1px 1px 3px rgba(0,0,0,.1);
    position: absolute; display: none; z-index: 2147483647; max-height: 254px; overflow: hidden; overflow-y: auto; box-sizing: border-box;
}
.wb-autocomplete-suggestion { position: relative; padding: 0 .6em; line-height: 23px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 1.02em; color: #333; }
.wb-autocomplete-suggestion b { font-weight: bold; }
.wb-autocomplete-suggestion.selected { background: #f0f0f0; }
</style>
<script type="text/javascript">
__wm.bt(550,27,25,2,"web","http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html","2006-10-29",1996);
</script><div class="wb-autocomplete-suggestions " style="left: 167px; top: 23px; width: 612px;"></div>
<!-- END WAYBACK TOOLBAR INSERT -->
<a name="LISP-History" <="" a="">
<h1>The Influence of the Designer on the Design -- J.~McCarthy and LISP</h1><p></p><p>
</p><h2>Herbert Stoyan
University of Erlangen
D-852 Erlangen, Germany</h2><p></p><p>

</p><h2>Abstract</h2><p>
In this chapter, some of the events of LISP development are protocolled. 
Step by step, the
implementers became independent of McCarthy. In 1962 the internal drive was
stronger than McCarthy's proposals. The results are somehow ambiguous.
</p><h2>Preparation for the Design</h2></a><p><a name="LISP-History" <="" a="">
Around 1956 </a><a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/mccarthy.gif">McCarthy</a> understood the central role of a programming language
for his scientific goal -- artificial intelligence. A consulting job in 1957
enabled him to experiment with a combination of algebraic notation (as it is
used in FORTRAN for describing arithmetical computation) and list processing
(as it was invented by Newell, Shaw, and Simon). The experiment was successful
and the idea became for him a basis of thinking.

He analyzed existing programming languages more deeply (using FORTRAN as
model) and started 
to ask for new means of expression. Before September 1958, McCarthy had
proposed in several papers\footnote{A memorandum for the leader of MIT's 
computer center, his contribution to the US proposal for the new International 
Algorithmic Language, and a letter to Backus and Turanski.} a list of around 24
new ideas for programming languages. First, he was out to advance the syntactic
face of the languages by introducing: </p><p>
(1) the changeability of typographical 
conventions, </p><p>
(2) the possibility to define new terminology (abbreviations), </p><p> and</p><p>
(3) the possibility to describe program variants as substitution operations on
programs.</p><p>

Then he was keen to upgrade the compilers by proposing: </p><p>
(4) extensibility of 
programs (incremental compiler) and changeability of programs, </p><p>
(5) writing the 
compiler in the language and bootstrapping it, </p><p>and </p><p>
(6) permitting compiler 
hints in the user program.

Next he called for means to: </p><p>
(7) change the arithmetic and 
the meaning of operation symbols, </p><p>
and </p><p>
(8) generalize the concept of the
subscripted
variables where the set of subscripts can be any ordered set. 

He
asked for new data types such as: </p><p>
(9) strings and lists as quantities, </p><p>
(10) 
possibilities for manipulating symbolic quantities, </p><p>(11) definability of new 
quantities (algebraic and functional expressions, differential equations, 
shapes, colors, programs, electrical networks), </p><p>(12) functions as quantities, </p><p>
(13) operations on functions (operations of the range, composition, 
abstraction, differentiation, integration), </p><p>(14) Church's 
lambda-notation, </p><p>(15) higher order functions, </p><p>and </p><p>(16) multiplet-valued 
functions\footnote{McCarthy's proposal is not covered by
the functionality of CommonLISP for multiple values. In addition to the
existing stuff, we need: a macro/specialform {\tt multiple-value-call*} which
accepts sequences of functions and applies them to consecutive multiple values,
and a macro/specialform {\tt multiple-value-distribute}, which accepts a
sequence of multiple values, and rearranges them. (Copying is permitted.)
McCarthy proposed a composition expression (written infix), which would lead to
one new macro/specialform {\tt multiple-value-compose}.}.

Further, he insisted on complete new language constructs: </p><p>(17) conditional 
expressions, </p><p>(18) fluents,\footnote{equations acting as demons} </p><p>(19) meta 
propositions (``{\it a} has been done already''), </p><p>and, </p><p>(20) a direct way of 
handling propositions and predicates and conditional functions.

Finally, he envisioned new ways of programming altogether: </p><p>(21) programming by 
equations between 
computing states (conditional, collections), </p><p>(22) the ability to describe a 
computation by giving final state of the machine in terms of the initial state 
without having to worry about intermediate changes to the variables used in the
computation, </p><p>(23) a way of describing flow apart from the computation 
statements, </p><p>and </p><p>(24) the possibility to describe problems by procedures that 
check solutions.</p><p>

Not all of these proposals are reality today. Some of them are quite technical;
but most of them turned out to be important for programming.</p><p>

In a proposal for a rigid intermediate language, he pointed out the advantages
of Polish notation and of an expression language. 

We see that McCarthy's thoughts were captured very much by the expressive tool
he wanted to realize in order to program intelligent systems and this became
possible through the AI project at MIT.
</p><h2>The First Development of LISP</h2><p>
The initial plan <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/memo1.gif"> {McC58b}</a> for LISP was as an extension of FORTRAN. McCarthy wrote 
proposals, 
modeled programs on paper and made his programmers implement the functions
by hand-compiling them. There is the unexplained fact that McCarthy, who
had already proposed lambda-expressions as part of a programming language
(for ALGOL in summer 1958), started into the adventure of designing
his algebraic language without taking this idea into account. $\lambda$ was 
forgotten the first time.</p><p>

According to his idea of an intermediate
language, he proposed to represent the language by expressions using
list structures. It was clear that Polish notation of expressions and 
the representation of terms as </p><p>
$f(e_1,...,e_n)$ by {\tt (f, e$_1$,...,e$_n$)}</p><p>
should be taken. 
In this way, the external representation of lists and the specification for the
read procedure was defined. With his FLPL experience, he
invented a series of basic functions
for list processing, including {\tt car}, {\tt cdr} (not {\tt cons}!) --
extraction, construction, reference, storage, erase, and pointer moving
 functions. </p><p>

The design was based on McCarthy's old ideas, with the exception that  
arithmetic did not play the
central role, as in the algorithmic languages. List processing, algebraic 
notation, recursive subroutines, conditional expressions, functions as
quantities -- these were the new features of the languages. </p><p>

The following basic quantities (data types) were chosen: </p><p>(1) integers -- as 
addresses,\footnote{McCarthy had not mastered the list
as data type: ``While a number of interesting and useful operations on whole
lists have been defined, most of the calculations we actually perform cannot
as yet be described in terms of these operations. It still seems necessary to
compute with the addresses of the elements of the lists.''\cite{McC58b}}
</p><p> (2) whole words, </p><p>
(3) propositional quantities -- i.e. booleans, </p><p>(4) locationals -- program 
labels, </p><p>and </p><p>(5) functions.

Symbols -- indentified with their p-lists (``each symbol in the program has 
such a p-list'') -- were not regarded as separate types.

The language should contain variables, indexed variables, expressions, 
conditional expressions and a small set of statements: </p><p>(1) a replacement 
statement -- assignment, </p><p>(2) a Go-statement -- transfer of control, </p><p>(3) a
set-statement -- array-creation, </p><p>(4) the subroutine-call, </p><p>(5) a compound 
statement, </p><p>(6) iteration statements -- a {\tt do} over an explicitly given 
list,</p><p> (7) declarations -- p-list construction (an imperative act!), and (8) 
subroutine definition -- a declaration.</p><p>

Hand-compiling {\tt maplist} convinced McCarthy of a necessary function 
notation
-- which completes the function quantity already proposed. He introduced the
lambda-notation after some time, but the proposals for the hand compilation
were usable only for compiled function arguments.</p><p>

Call by value was taken as FORTRAN's strategy.</p><p>

By reading the old report <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/memo2.gif">\cite{McC58c}</a>, one becomes convinced that McCarthy knew enough
about the process of hand compilation to enable him to observe the programmers 
carrying out their work. The programmers were quite clever and did much
outside of LISP.\footnote{Model railroads, space war programming, etc.}
</p><h2>The Revision</h2><p>
After two months of
paper programming and hand-compiling small functions, J.~McCarthy changed the
design nearly to that of a functional language <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/memo3.gif">\cite{McC58d}</a>. </p><p>

The representation of list structures became clearer, symbols and
lists\footnote{The empty list is a 15 bit quantity (a pointer) 0, the truth 
value false a 1 bit quantity 0.} got their structure.  It was decided to 
represent the difference between 
constants and variables not in notation but as property in the p-lists.</p><p> 

All 3-bit quantities of the first design were dropped. Work with whole words 
remained only in connection with p-names, {\tt cons} was created from 
{\tt consel} and {\tt consls}. All storage and pointer moving functions were
removed.</p><p>

Functions were taken as objects with p-lists, i.e., symbols. This was a 
dangerous
 step. The intention was to store in the p-list: the fact that this is a 
function, a calling sequence, formulas for differentiating and integrating.
</p><p>
The revision was initiated by the decisions for storage structures and the
paper programs written so far by McCarthy.
</p><h2>Further Concretization</h2><p>
The next step was the design of storage management for recursive routines. Some
FORTRAN standards were taken. McCarthy understood that recursive functions are
quite concise but not always efficient. He presented an iterative {\tt maplist}
 which worked with a local variable {\tt maplist}. It was an imperative version
using a cycle. He discussed the ratio of speed penalty versus 
ease of statement. The language still permitted changing of lists by writing 
{\tt car} or similar on the left side of an assignment 
statement.\footnote{Modern version: {\tt (setf (car list) new-car)}.}</p><p>

In <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/storage.gif">Memo 4</a> \cite{McC58e}, we find the first usage of the name LISP. 
Additionally, it 
contains SAP programs for {\tt cons}, {\tt copy}, {\tt maplist}, {\tt diff}, 
proving that McCarthy was leading the implementation work.</p><p>

Substitutional functions were the most advanced things at the end of October.
``The value of a substitutional function applied to a list of arguments is the
result of substitutions (substituting) these arguments for the objects on an
ordered list of arguments in a certain expression containing these arguments.''
If we apply the proposed representation to square, we get:
 {\tt(subfun (x) (times x x))}. $\lambda$ is not used! This is quite surprising
here -- the second time that this happened. The first {\tt apply} is 
represented as a substituting function:</p><p>


apply(L,f) = (car(f) = subfun -&gt; sublis(pair(car(cdr(f)),L),car(cdr(cdr(f))))
</p><p>              1 -&gt; error)


This {\tt apply} can deliver only list representations of body forms of the 
function.
It is interesting to see the first hint for the necessity of automatic storage 
management -- ``{\tt apply} is a space thief unless the compiler arranges for 
the list to be erased once it was used.''
</p><h2>The Gap</h2><p>
Memo 4 was written between the end of October and early November.
<a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/memo7.gif">The next memo (7)</a> by McCarthy, was written in spring 1959 \cite{McC59a}. 
It contains proposals initiating the work on the compiler. In the text
we find the first usage of the symbol {\tt cond} as a compiler case. 
</p><h2>A Contribution -- Nat Rochester</h2><p>
It seems that during McCarthy's leave Rochester presented his <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/manipul.gif">Memo 5</a>
containing the first proposal for an algebraic simplifier \cite{R58}. Between 28th
of October and 20th of November, he developed various functions and proposed 
some
alternatives e.g. the compositions of {\tt car} and {\tt cdr}, 
such as {\tt caadaddr}, the first {\tt append}, {\tt eq}, (full-word) {\tt 
replace}, a complete {\tt simplify}, an incomprehensible complicated {\tt diff}.
Rochester always wrote ``list processing language'', instead of LISP.</p><p>

In a handwritten Memo 5, McCarthy tried to redo Rochester's functions.
The script contains only three functions: {\tt conc} = {\tt insert}, {\tt 
subfp}, 
{\tt adj} = {\tt var}. He did not use the {\tt car}-{\tt cdr} compositions and 
proposed (not in the draft) a function {\tt desc}, which accepted a list of 
{\tt a} and {\tt d} to simulate the work of the composition. In \cite{McC59d}, 
McCarthy converts to the short {\tt car}-{\tt cdr} composition.</p><p>

It is hard to comment on this: possibly a tendency to do everything
alone? Rochester's {\tt label} proposal was accepted -- in another form.
</p><p>
Two papers for users were written now which meant there were some -- outside
the circle of McCarthy, Russell, and Maling. <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/debug.gif">Memo 6 by S.~Russell</a> is on writing 
and debugging programs. The earlier handwritten memo by McCarthy, ``Notes on 
Debugging LISP Subroutines,'' proves again his machine knowledge. It was
now possible to input lists. McCarthy had some hope to ``relax input 
conventions.''\footnote{Poor LISPers! This still has not happened!}
Assignment is described as: {\tt equal(y, (plus, a, (times, b , c)))}
     for {\tt y = a+b*c}!</p><p>

McCarthy started to define the restricted language  that is ``the official 
form of the notation,'' but did not finish this.</p><p>

The December Quarterly Progress Report \cite{McC58f} announced a forthcoming 
RLE tech report
describing the LISP system. A small hint in this direction is given:
``{\tt apply} is programmed but not yet debugged. It will be the basis of an 
interpreter.'' Is that the small {\tt apply} of November, a substituting 
program, or an a-list using one? It remains unknown.
</p><h2>The First Known Interpreter</h2><p>
Some time between November 1958 and March 1959, McCarthy got the idea to prove 
the equivalence of his LISP to Turing machines by developing a universal LISP
function that simulates LISP functions by processing a list representation
of them. As McCarthy reports in \cite{McC78}, S.~Russell took the function, 
intended for theoretical purposes only, and hand-compiled it. The story is nice,
but the implementation purpose is quite obvious. The new functions fulfill the
purpose of the {\tt apply} of Memo 4. </p><p>

In \cite{S84}, I published an {\tt apply}/{\tt eval} as the first known 
interpreter. It
is contained in Memo 8,\footnote{See section 9.} \cite{McC59b}, which is dated the 4th 
March. In the meantime, we have found an {\tt apply}/{\tt eval} -- which is one 
day older\cite{MetC59}! In addition, it comes in the tenth
modification and is the following program\footnote{To present it as near 
to the original as possible, I have changed $\lambda$ to \&amp;, exchanged the 
handwritten arrows to {\tt -&gt;}, and one $\vee$ to {\tt v}.}
 (titled ``LISP program for single statement interpreter''):</p><p>

</p><h4><pre>APPLY(F,L,A)=select(car(F);
          -1,app2(F,L,A);
          lambda,eval(caddr(F),append(pair(cadr(F),L),A));
          label,apply(caddr(F),L,append(pair(cadr(F),caddr
                           (F)),A));
          apply(eval(F,A),L,A))
EVAL(E,A)=select(car(E);
          -1,search(A,&amp;(J,caar(J)=E),&amp;(J,cadar(J)),error);
          intv,search(cadr(E),&amp;(J,car(J)=int),&amp;(J,cdadr(J)),
                           error);
          sub,sublis(A,eval(cadr(E),A));
          const,cadr(E);
          label,eval(caddr(E),append(pair(cadr(E),caddr(E)),
                           A));
          varc,search(A,&amp;(J,cadar(J)=cadr(E)),&amp;(J,cadar(J)),
                           error);
          care,search(A,&amp;(J,caar(J)=cadr(E)),&amp;(J,eval(cadar(J),
                           cdr(J)),error);
          apply(car(E),maplist(cdr(E),&amp;(J,eval(car(J),A))),A))
APP2(F,L,A)=select(F;caar,caar(L);cdr,cdar(L);cons,cons(car(L),cadr(L));
          list,L;null,car(L)=0;atom,caar(L)=-1;
                           search(F,&amp;(J,car(J)=subr v expr),
                                &amp;(J,(car(J)=subr -&gt; app3(F,L,    
                                1 -&gt; apply(cadr(J),L,A))),
          search(A,&amp;(J,caar(J)=F),&amp;(J,apply(cadar(J),L,A)),
                                error))
evcon(E,A) = (E=0 -&gt; error,eval(caar(E),A) -&gt; eval(cadar(E),A),1 -&gt; evcon
                                  (cdr(E),A))
</pre></h4>
This program is erroneous, obviously. Parentheses are lacking (lines 18,
26) and the end of a line is lost, (line 23, {\tt A);}).<p>

The system is a call-by-value system using a-lists. The a-list is not a list
of pairs but a two-element list.</p><p>

The clauses in {\tt EVAL} correspond to: atom symbols, integers,\footnote{The 
evaulator delivers the digit representation!} substitutional 
functions,\footnote{Relic of November 1958.} {\tt quote},\footnote{Named 
{\tt const}} {\tt label},\footnote{Evaluates the body after associating name 
and body.} and two cases
of variables.\footnote{The second are variables with unevaluated values
on the a-list, the first are variables with evaluated values on the a-list -- {
\tt cadar} is a mistake and should be changed into {\tt caar}.
Both are coded as lists: {\tt (varc x)} the first, and {\tt (vare x)} the
second; the {\tt c} must be a writing error. Are they relics of the earlier
interpreter versions?} A clause for $\lambda$ is missing -- the third time 
$\lambda$ was forgotten. An explanation might be the start in
substitutional functions.</p><p>

{\tt APPLY} has clauses for functions named by symbols, by 
lambda-expressions, and by {\tt label}. Other cases are given to {\tt eval} to 
repeat the evaluation of
the function. {\tt APP2} executes {\tt car}, {\tt cdr}, {\tt cons}, {\tt list},
{\tt null}, and {\tt atom} directly. All other implemented functions are
activated via their functional property: {\tt subr} and {\tt expr} are checked
together. Afterwards the a-list is checked for local bindings of the symbols.
The global definition has preference.
</p><p>
The code looks good\footnote{If we
assume hand-compiled {\tt search}. The 4th parameter is an expression that
should not be evaluated before executing {\tt search}. Two {\tt pair}-forms
are intended for different purposes.} -- with the exception of processing 
functional arguments, of course. We find this in accordance with it with
the comments in the assembly listing of May 1959 (see \cite{S84}). Only the 
{\tt cond}-clause was added.
</p><h2>Theoretical Interpreters</h2><p>
With a defined interpreter, the development of the language was more for
debugging and convenience than for design and deep ideas. Russell did his
duty and debugged; McCarthy worked on the theory of S-expressions.</p><p>

McCarthy has published many interpreters. In \cite{S84}, I have republished
versions which were written in March and April 1959. The latter 
developed into the version published in the CACM-paper \cite{McC60}.
All of them are to be regarded as theoretical programs that
are on paper only and have no impact on practice.</p><p>

The <a href="https://web.archive.org/web/20061029131004/http://www8.informatik.uni-erlangen.de/html/gif/symbolic.gif">first known version \cite{McC59b} of the CACM-paper</a> is dated March 4. The 
aim of
this paper was to prove that LISP is as powerful as Turing machines. For this
purpose, McCarthy (1) implemented Turing machines and (2) proved that there is
a universal LISP-function.</p><p>

The important breakthrough was the introduction of symbolic expressions as
data type for list structures and the conversion of the basic function from
pseudo functions on integers to functions on symbolic expressions.</p><p>

During this research, McCarthy felt uneasy with the machine dependent names of 
the selector functions (additionally, {\tt cons} was not regarded as good 
enough) and
he tried to change\footnote{{\tt first} instead of {\tt car}, {\tt rest}
instead of {\tt cdr}, {\tt combine} instead of {\tt cons}.}  that. Programmers 
and students were surprised by McCarthy's new
language, but nobody took up his proposal and after some days he dropped
it. The LISP community was already more powerful as the designer.</p><p>

For representing LISP-functions as lists, McCarthy had designed the well known 
translation rules from LISP\footnote{The 
``F-expressions'', later ``M-Language''.} to symbolic expressions.\footnote{
``S-expressions'' became the ``S-language'' and then plain LISP.} There was
a rule for each part of the language, the constants, the variables and function
names, the forms, the null S-expression, the truth values,
the conditional expression, the lambda-expressions, the label-expressions,
and equalities. These translation rules alone created a lot of trouble later: 
the introduction of the symbol {\tt NIL} to represent the empty s-expression (=
the empty list).\footnote{On March 20 empty lists and sublists still were 
printed as blanks! Until summer, the empty list was coded as {\tt (intv 0)}. 
At what stage
the interpreter accepted {\tt NIL} for it and {\tt T} for ``true'' is not 
known. The best decision would have been {\tt()}.} In the case of the 
truth values the f-expressions contained numbers, their translation were 
unquoted symbols.</p><p>
</p><pre>apply[f;args] = eval[combine[f;args]]
eval[e] = [
first[e]=NULL -&gt; [null[eval[first[rest[e]]]] -&gt; T;1 -&gt; F]
first[e]=ATOM -&gt; [atom[eval[first[rest[e]]]] -&gt; T;1 -&gt; F]
first[e]=EQ -&gt; eval[first[rest[e]]]]=eval[first[rest[rest[e]]]] -&gt; T;
     1 -&gt; F]
first[e]=QUOTE -&gt; first[rest[e]];
first[e]=FIRST -&gt; first[eval[first[rest[e]]]];
first[e]=REST -&gt; rest[eval[first[rest[e]]]];
first[e]=COMBINE -&gt; combine[eval[first[rest[e]]];eval[first[rest[rest
     [e]]]]];
first[e]=COND -&gt; evcon[rest[e]];
first[first[e]]=LAMBDA -&gt; evlam[first[rest[first[e]]];first[rest[rest
     [first[e]]]];rest[e]];
first[first[e]]=LABEL -&gt; eval[combine[subst[first[e];first[rest
     [first[e]]];first[rest[rest[first[e]]]]];rest[e]]]]]

evlam[vars;exp;args]=[null[vars] -&gt; eval[exp];1 -&gt; evlam[
     rest[vars];subst[first[args];first[vars];exp];rest[args]]]
</pre>
The universal S-function {\tt eval}\footnote{{\tt apply} was based on 
{\tt eval} completely.} given in the same paper \cite{McC59b}
(see above) is a complete 
interpreter of LISP -- a substituting call-by-name realization of an applied 
lambda-calculus. McCarthy did not know this. He realized LISP -- and LISP 
used lambda-{\em notation}. This may explain why he forgot a clause for 
lambda-expression in this {\tt eval}. It was the fourth time he forgot 
$\lambda$. There are two main errors: McCarthy ignored the computation of 
functions and
he used a too general substitution procedure. He corrected the latter a little
but it remained incorrect because of forgotten variable lists in 
lambda-expressions.<p>

This leads to the question of McCarthy's knowledge of the lambda-calculus. 
McCarthy always pointed out that he did not know much about
this. It is obvious that he has read the first pages of Church's
paper \cite{C41}. The {\tt eval} of March 1958 proves that he did know about
substitution. However, there is no sign of renaming variables, no sign of 
normalization. One cannot believe that McCarthy did not study carefully the 
substitution procedures of the lambda-calculus for his realization, but 
this 
is the only explanation for a series of errors that were not apparent in the
simple examples of 1958. Today, we all know much better.</p><p>

The second theoretical interpreter was published in \cite{McC59c}. (See 
below.) This changed
the substitution procedure into a frozen one -- the a-list was used as in the
running system. The interpreter works with a mixture of evaluated and
unevaluated arguments. Top level is {\tt apply}. The arguments are quoted and 
{\tt eval} is activated. Argument subterms are not evaluated if the function is
 written as lambda-expression. Basic functions have to evaluate their 
arguments. If there is an
expression (or a variable as function name) in functional position, arguments
are evaluated. After argument evaluation, the values are quoted. This way, 
arguments do not get evaluated twice -- but {\tt evlis} strips quotes off and
puts them on again: a waste of storage. In the a-list, quoted values 
and
unevaluated arguments are mixed. On access, the values get evaluated in the
actual environment, which might be quite different than the original one.</p><p>

</p><pre>apply[f;args] = eval[cons[f;appq[args]];NIL]

appq[m] = [null[m] -&gt; NIL;T -&gt; cons[list[QUOTE;car[m]];appq[cdr[m]]]]

eval[e;a] = [
  atom[e] -&gt; eval[assoc[e;a];a];
  atom[car[e]] -&gt; [
  car[e]=QUOTE -&gt; cadr[e];
  car[e]=ATOM -&gt; atom[eval[cadr[e];a]];
  car[e]=EQ -&gt; [eval[cadr[e];a]=eval[caddr[e];a]];
  car[e]=COND -&gt; evcon[cdr[e];a];
  car[e]=CAR -&gt; car[eval[cadr[e];a]];
  car[e]=CDR -&gt; cdr[eval[cadr[e];a]];
  car[e]=CONS -&gt; cons[eval[cadr[e];a];eval[caddr[e];a]];
  T -&gt; eval[cons[assoc[car[e];a];evlis[cdr[e];a]];a]];
  caar[e]=LABEL -&gt; eval[cons[caddar[e];cdr[e]];cons[list[cadar[e];car[e];a]];  
  caar[e]=LAMBDA -&gt; eval[caddar[e];append[pair[cadar[e];cdr[e]];a]]]

evlis[m;p] = [null[m] -&gt; NIL;T -&gt; cons[list[QUOTE;eval[car[m];a]];
             evlis[cdr[m];a]]
</pre>

A functional argument is processed correctly, if a lambda-expression or
symbol is written as argument of a form
with lambda-expression as function and if the naming variable is
directly used in functional position. The other cases are erroneous because
a case for $\lambda$ in {\tt eval} is lacking. A later version \cite{MetC60b}
cleared up the differences in argument evaluation -- now strictly
 call-by-value:<p>

</p><pre>apply[f;args] = eval[cons[f;appq[args]];NIL]

appq[m] = [null[m] -&gt; NIL;T -&gt; cons[list[QUOTE;car[m]];appq[
          cdr[m]]]]

eval[e;p] = [
  atom[e] -&gt; [assoc[e;p];
  atom[car[e]] -&gt; [
    eq[car[e];QUOTE] -&gt; cadr[e];
    eq[car[e];ATOM] -&gt; atom[eval[cadr[e];p]];
    eq[car[e];EQ] -&gt; eq[eval[cadr[e];p];eval[caddr[e];p]];
    eq[car[e];COND] -&gt; evcon[cdr[e];p];
    eq[car[e];CAR] -&gt; car[eval[cadr[e];p]];
    eq[car[e];CDR] -&gt; cdr[eval[cadr[e];p]];
    eq[car[e];CONS] -&gt; cons[eval[cadr[e];p];eval[caddr[e];p]];
       T -&gt; eval[cons[assoc[car[e];p];evlis[cdr[e];p]];p]];
    eq[caar[e];LABEL] -&gt; eval[cons[caddar[e];cdr[e]];cdr[e]];
       cons[list[cadar[e];car[e]];p]];    
    eq[caar[e];LAMBDA] -&gt; eval[caddar[e];append[pair[cadar[e];
       evlis[cdr[e];p];p]]]]

evlis[m;p] = [null[m] -&gt; NIL;T -&gt; cons[list[eval[car[m];p];
             evlis[cdr[m];p]]]]
</pre>

The additional {\tt list} in {\tt evlis} is superfluous.
Functional arguments are always processed erroneously -- they are forgotten.<p>

Comparing the theoretical interpreters with the realized one of March 1959,
we get the feeling of a theory behind practice.
The picture of a McCarthy who sits in his room alone and designs a nice 
theory for purposes of pure science is quite wrong. There is enough written 
proof that he initiated writing the manual and serving users better.
McCarthy worked out the idea of garbage collection and he introduced the 
``program feature.'' On the other hand, it was N.~Rochester who organized the 
first big
LISP application -- symbolical computation of electrical networks. Therefore, 
we
shall assume a scenario in which McCarthy became increasingly interested in his
theoretical work, delivering still the key ideas for the language and the 
system, but not greatly controlling the work of the programmers.
</p><h2>Combining Expressions and Statements</h2><p>
The programmers could not program in a function-oriented style. Even McCarthy
had discussed a version of {\tt maplist} that was programmed iteratively
to save time. In 1958 LISP permitted sequential programming and
usage of {\tt go}. The differentiation program designed by McCarthy and
maintained by Maling \cite{M59} already contained {\tt return}-forms. Later, 
{\tt apply} somehow
could handle sequential programs. McCarthy refers to this in \cite{McC59d}
but does not go into details. We know from recollections of students and
programmers that they misused the conditional expression for constructing
sequences of statements.\footnote{The function {\tt enterm} in Goldberg's 
system \cite{G59} is a nice example.}
Goldberg shows the {\tt prog}-notation in his thesis but when this was 
introduced is not known.</p><p>

It is interesting to note that McCarthy regarded his function-oriented 
programs as sets of recursive functions, and the statement-oriented programs 
as real programs.</p><p>

McCarthy's proposal of May '59 was to write sequences of assignments as a list
of pairs of the variable and the expression. Obviously, his ideas of 1958
to code a program by the results of variables were applied. Contrary to the old
 proposal he now used the list of variables and 
expressions to represent a sequence of assignments and not a system
of equations. An idea to represent the latter is also contained in the paper
\cite{McC59d}.
</p><h2>Garbage Collection</h2><p>
Until March '59, the erasure functions played an important role -- at least in 
the
manuals. There is no known LISP code that ever used {\tt eralis} and {\tt 
erase}. The students who implemented the electrical network system must have
written increasingly bigger programs -- and one day the storage was used
up. McCarthy often remarked ``this function is a space thief,'' and this
was valid for the {\tt apply}/{\tt eval}-interpreter in any case. Now a good 
idea was necessary. McCarthy delivered the idea of garbage collection. The 
version of the CACM-paper \cite{McC59c} that appeared in April 1959, in the 
Quarterly Progress Report, contains the first explanation. The garbage 
collector
 was implemented during summer 1959 by S.~Russell and D.~Edwards.
</p><h2>The Funarg Problem</h2><p>
In May already -- if not earlier -- it turned out that the {\tt lambda}-case 
was missing in {\tt eval}. Functional arguments often occurred as 
{\tt maplist}, {\tt search}, and other functions did need some, and a named 
function did not always seem appropriate. Adding quotations was introduced, but
 this seemed a little strange because labeled lambda-expressions need no quotations. A bug 
was not assumed -- which suggests that the programmers did not study McCarthy's
 papers carefully.</p><p>

In the fall of 1959 J.~Slagle was programming for his integration system
SAINT\cite{JS61}. He was probably the first who detected the bug in the way 
functional arguments were processed. Four years later, Saunders still used 
Slagle's
case as an explanation example. As is well-known, the error shows up as a wrong
value of a (relatively) global variable in a function written as 
lambda-expression and quoted for being accepted as a functional argument. If 
the function is activated outside its orignal environment, the binding of the
global variable has changed. McCarthy admits that he underestimated the 
problem. ``I must confess that I regarded this difficulty as just a bug and 
expressed confidence that Steve Russell would soon fix it...'' \cite{McC78}.
The analysis proved that the environment for the global variables had to be
taken. The solution was the {\tt funarg} or, better, the closure. The solution
was realized as a patch that did not remove the source of the problem -- the 
missing case for $\lambda$ in {\tt eval}. Instead, a variant of 
{\tt quote} was invented, {\tt function}. The first known (practical) 
interpreter including the
{\tt funarg} device is published in \cite{MetC60a}:</p><p>

</p><pre>apply[f;x;a] = [atom[f] -&gt; app2[f;x;a];
     car[f] = LAMBDA -&gt; eval[caddr[f];append[pair[cadr[f];x];a]];
     car[f] = LABEL -&gt; apply[caddr[f];x;append[pairl[cadr[f];
                caddr[f]];a]];
     car[f] = FUNARG -&gt; apply[cadr[f];x;caddr[f]];
                T -&gt; apply[eval[f;a];x;a]]

eval[e;b] = [atom[e]-&gt;search[e;&amp;[[j];car[j] = APVAL v car[j] = APVAL1];
                &amp;[[j];caadr[j]];
                &amp;[[j];search[b,&amp;[[j];caar[j] = e];
                          &amp;[[j];cadar[j]];
                          &amp;[[j];error]]]];
     atom[car[e]] -&gt;
       search[cdar[e];&amp;[[j];car[j] = FSUBR v car[j] = SUBR v car[j] =
       FEXPR v car[j] = EXPR];
          &amp;[[j];select[car[j];
              [FSUBR;app3[cadr[j];list[cdr[e];b]]];
              [SUBR;app3[cadr[j];evlis[cdr[e];b]]];
              [FEXPR;apply[cadr[j];list[cdr[e];b];b]];
              apply[cadr[j];evlis[cdr[e];b];b]]]
          &amp;[[j];search[b;
                 &amp;[[j];caar[j] = car[e]];
                 &amp;[[j];apply[cadar[j];evlis[cdr[e];b];b]];
                 &amp;[[j];error]]]];
      T -&gt; apply[car[e];evlis[cdr[e];b];b]]

app2[f;x;a] = select[f;[CAR;caar[x]];[CDR;cdar[x]];
                [CONS;cons[car[x];cadr[x]]];
                [LIST;x];
                search[f;&amp;[[j];[car[j] = SUBR v car[j] = FSUBR]];
                   &amp;[[j];[car[j] = SUBR -&gt; app3[cadr[j];x];
                   T -&gt; apply[cadr[j];x;a]];
                   &amp;[[j];apply[car[sassoc[f;a;error]];x;a]]]]
</pre>

This code would be fine (with exception of the disparity between handling of
global functional and normal values), if {\tt lambda} were a {\tt FEXPR} 
creating the {\tt FUNARG}. The multitude of ``functional'' objects is
introduced.<p>

The funarg event proves that McCarthy was now far from his LISP. He won the
theoretical battle und searched for the next field. The mathematical theory
of computation, time sharing, and proof checking were his new interests. LISP
lost first priority.
</p><h2>The Last Blow</h2><p>
The theoretical interpreter of July 1961 has a different face, but there are
no functional changes (still without closures) \cite{MetC61}:</p><p>

</p><h4><pre>evalquote[fn;x] = apply[fn;x;NIL]
apply[fn;x;a] = [eq[fn;NIL] -&gt; NIL;
     atom[fn] -&gt; [eq[fn;CAR] -&gt; caar[x];
                  eq[fn;CDR] -&gt; cdar[x];
                  eq[fn;CONS] -&gt; cons[car[x];cadr[x]];
                  eq[fn;ATOM] -&gt; atom[car[x]];
                  eq[fn;EQ] -&gt; eq[car[x];cadr[x]];
            T -&gt; apply[eval[fn;a];x;a]];
     eq[car[fn];LAMBDA] -&gt; eval[caddr[fn];pairlis[cadr[fn];x;a]];
     eq[car[fn];LABEL] -&gt; apply[caddr[fn];cons[con[cadr[fn];
                                          caddr[fn]];a]]];  

eval[e;a] = [atom[e] -&gt; cdr[assoc[e;a]];
     [atom[car[e[ -&gt; [
             [eq[car[e];QUOTE] -&gt; cadr[e];
             [eq[car[e];COND] -&gt; evcon[cdr[e];a];
             T -&gt; apply[car[e];evlis[cdr[e];a];a]]
     T -&gt; apply[car[e];evlis[cdr[e];a];]]
              
evlis[m;a] = [cons[eval[car[m];a];evlis[cdr[m];a]]];
</pre></h4>

In 1961 while working 
at the proofchecker, McCarthy detected unexpected behavior of the implemented 
LISP~1.5 system. He analyzed the situation \cite{McC62} and came to 
the unfortunate conclusion that his theoretical {\tt eval} and the real 
running {\tt eval} both had 
errors. ``Neither of these behaves in the most desirable way; and there exist
S-expressions which will be handled correctly by the theoretical version
but not by the system version, and conversely. The chief defect of the system
eval lies in its handling of functional arguments; the chief defect of the
RFSE eval lies in its ignorance of property lists.'' <p>

``Property list'' should be read as ``global environment.'' For functions, it 
was represented in the realized system by symbols 
and their values associated with {\tt expr}, {\tt fexpr}, {\tt subr}, and 
{\tt fsubr} indicators on the p-list. For other values, it was represented by 
symbols and their values associated with {\tt apval} indicators on the p-list.
The special thing about the working system\footnote{And still is in
CommonLISP!} was its double semantics (value spaces) of variables. In 
functional positions, the value of a symbol was associated with the functional 
indicators in the p-list. If there was not such a value, the symbol was taken
as an ordinary variable and evaluated -- first as a (global) value associated 
to 
the {\tt apval} indicator in the p-list and then as a value in the a-list. In
argument position, the global function value never would have been consulted
-- even if the programmer intended to deliver a function.
If the theoretical {\tt eval} contained a representation for 
the global environment, this would be a solution for this part of the 
problem. The a-list together with a variable denoting it or another external 
notation for the global environment would be enough. </p><p>

McCarthy correctly saw two solutions for this problem: using a permanent a-list
or using one value indicator in the p-list.</p><p>

There was no important difference between theoretical and implemented {\tt 
eval} regarding the handling of functional arguments. In fact, both of them
ignored functional arguments. Instead, the programmer had to ``underline''
functional arguments in the running systems. The {\tt function} prefix was 
needed for lambda-expressions in argument positions only. For 
variables (symbols), {\tt function} worked as {\tt quote}. The access to global
functional values is done in {\tt apply} via one step of indirection using
{\tt eval} to change the local functional variable into the function name
argument.
If one makes global function names evaluable, then this indirection is 
unnecessary. The local variable gets the functional value of the function name
when the arguments are evaluated. For function names, the quotation would
become superfluous. For lambda-expressions, the problem of evaluation
remains. To solve it, McCarthy proposed the definition of {\tt lambda} as
{\tt fexpr}: {\tt ((lambda(e a) (cons 'lambda e)))}. It is obvious that he did
not have in mind the {\tt funarg}-problem, i.e., the environment-problem.
Therefore, the solution presented is only a half one. But it is easy to add the
other half. We are quite near to SCHEME!</p><p>

McCarthy developed the following interpreter description\footnote{McCarthy 
introduced super-parantheses: {\tt (..}, {\tt (.}, {\tt (,} etc.} \cite{McC62}:

</p><pre>eval (exp; alist) = (..atom(exp) -&gt; search (.exp;
        &amp; ((j);(eq(car(j); VALUE)));
          cadr;
           &amp; ((); assoc(exp; alist.)
t -&gt; prog((fnval);
     fnval = eval (car(exp); alist)
     return((fullword(fnval) v eq(car(fnval);LAMBDA)
      V eq(car(fnval);LABEL) -&gt; app l (fnval;
     maplist(,cdr(exp);&amp; ((j);eval(car(j); alist,); alist);
      t -&gt; app l (car(fnval); list(cdr(exp);alist);alist..)
app l(fn;args;alist) = (.
      fullword (fn) -&gt; app 2 (fn; args);
        eq(car(fn);LAMBDA) -&gt; eval(caddr(fn);append(
        pair(cadr(fn),args);alist));
        eq (car(fn);LABEL) -&gt; app l (caddr(fn); args;
       cons (cons(cadr(fn);caddr(fn)); alist.)
evalquote(fn;args) = app l (eval (fn;nil)args;nil)
</pre>

However, the LISP implementors did not use the new memo as a working 
direction, possibly because of the ``big bulk'' of programs already running -- 
still the 
only, and weak, argument of the pastors of LISP-errors today.<p>

Since this intervention, McCarthy has not made any more  written contributions 
to LISP.\footnote{But add his lectures, verbal proposals, work on parallel 
LISP!} Conversion to lambda-calculus, object-oriented 
extensions, and standardization did not interest him. He changed to the theory
of computation, to program verification, to proof checking, to nonmonotonic
logic, etc. 
</p><h2>Conclusion</h2><p>
If we compare McCarthy's proposals, his design, and the current state of
LISP, then it is remarkable how much was established so early. 
LISP would look like 3-LISP (without reflection, maybe) if McCarthy
had studied Church's paper more closely. As things stand, he
must prefer SCHEME to CommonLISP -- a clear, understandable small diamond, to
a messy, incomprehensible clump.
</p><h2>Bibliography</h2>
\bibitem{C41} A.Church: The Calculi of lambda-Conversion. Princeton, 1941.<p>
\bibitem{G59} S.Goldberg: Solution of an Electrical Network Using a Digital
Computer. Masters Thesis, EE Dept., MIT, Cambridge, MA, 1959.</p><p>
\bibitem{M59} K.Maling: The LISP Differentiation Demonstration Program. MIT 
AI Memo 10, Cambridge, MA, 1959.</p><p>
\bibitem{McC58a} J.McCarthy: Some Proposals for the Volume 2 Language.
MIT, Cambridge, MA, June 1958.</p><p>
\bibitem{McC58b} J.McCarthy: An Algebraic Language for the Manipulation of
Symbolic Expressions. MIT AI Memo 1, Cambridge, MA, September 1958.</p><p>
\bibitem{McC58c} J.McCarthy: A Revised Version of MAPLIST. MIT AI Memo 2, 
Cambridge, MA, September 1958.</p><p>
\bibitem{McC58d} J.McCarthy: Revision of the Language. MIT AI Memo 3, 
Cambridge, MA, October 1958.</p><p>
\bibitem{McC58e} J.McCarthy: Revisions of the Language. MIT AI Memo 4, 
Cambridge, MA, October 1958.</p><p>
\bibitem{McC58f} J.McCarthy: Artificial Intelligence Project, Semi-Annual 
Report, Cumputation Center, MIT, Cambridge, MA, December 1958.</p><p>
\bibitem{McC59a} J.McCarthy: Notes on The Compiler. MIT AI Memo 7, Cambridge,
MA, January (?) 1959.</p><p>
\bibitem{McC59b} J.McCarthy: Recursive Functions of Symbolic Expressions and
their Computation by Machine. MIT AI Memo 8, Cambridge, MA, March 4, 1959.</p><p>
\bibitem{McC59c} J.McCarthy: XIII. Artificial Intelligence. In: RLE Quarterly
Progress Report No.~53, MIT, Cambridge, MA, April 1959.</p><p>
\bibitem{McC59d} J.McCarthy: Programs in LISP. MIT AI memo 12, Cambridge, 
May (?) 1959.</p><p>
\bibitem{McC60} J.McCarthy: Recursive Functions of Symbolic Expressions and
Their Computation by Machine. CACM, Vol. 3 (1960), No.3, p.184-195.</p><p>
\bibitem{McC62} J.McCarthy: A New Eval Function. MIT AI Memo 34, Cambridge,
  MA,             1962 (?).</p><p>
\bibitem{McC78} J.McCarthy: History of LISP. ACM SIGPLAN Notices, Vol. 13 
(1978), No. 8, p.217-223.</p><p>
\bibitem{MetC59} J.McCarthy, S.Russell, K.Maling, N.Rochester, S.Goldberg,
J.Slagle: LISP Programmer's Manual. MIT AI Project, Cambridge, MA, March 1959.</p><p>
\bibitem{MetC60a} J.McCarthy, R.Brayton, D.Edwards, P.Fox, D.Luckham, 
K.Maling, D.Park, S.Russell:
 Preliminary LISP Programmer's Manual. Draft. Computation Center and 
RLE, MIT, Cambridge, MA, January 1960.</p><p>
\bibitem{MetC60b} J.McCarthy, R.Brayton, D.Edwards, P.Fox, D.Luckham, 
K.Maling, D.Park, S.Russell: LISP I Programmer's Manual. Computation Center and
RLE, MIT, Cambridge, MA, March 1960.</p><p>
\bibitem{MetC61} J.McCarthy, M.Minsky, P.Abrahams, R.Brayton, D.Edwards,
L.Hodes, D.Luckham, M.Levin, D.Park, T.Hart: LISP 1.5 Programmer's Manual. MIT 
AI Project, Cambridge, MA, July 1961.</p><p>
\bibitem{R58} N.Rochester: Symbol Manipulation Language. MIT AI Memo 5, 
Cambridge, MA, November 1958.</p><p>
\bibitem{JS61} J.Slagle: A Heuristic Program that Solves Symbolic Integration
Problems in Freshman Calculus. Ph.D.Thesis, Dept. of EE, MIT, Cambridge, MA,
1961.</p><p>
\bibitem{S84} H.Stoyan: Early LISP History (1956-1959). Conf.Rec. 1984 ACM
Symposium on LISP and Functional Programming. ACM, 1984.</p><p>
</p><p>
</p><h2>Two Further Interpreters</h2>
A second version in the manual of March 1960:
<pre>apply[f;x;p] = [atom[f] -&gt; app2[f;x;p];
      car[f] = LAMBDA -&gt; eval[caddr[f];append[pair[cadr[f];
               x];p]];
      car[f] = LABEL -&gt; apply[caddr[f];x;append[list[list[
               cadr[f];caddr[f]]];p]];
      car[f] = FUNARG -&gt; apply[cadr[f];x;caddr[f]];T -&gt; 
               apply[eval[f;p];x;p]]

eval[e;b] = [atom[e]-&gt;search[e;&amp;[[j];eq[car[j];APVAL] v 
            eq[car[j];APVAL1]];caadr;search[b;
            &amp;[[j];eq[caar[j];e]];&amp;[[j];cadar[j]];
            &amp;[[j];error]]]];
 atom[car[e]] -&gt;
   search[cdar[e];&amp;[[j];eq[car[j];FSUBR]v eq[car[j];
   SUBR]v eq[car[j];FEXPR]v eq[car[j];EXPR]];
   &amp;[[j];select[car[j];
   [FSUBR;app3[cadr[j];list[cdr[e];b]]];
   [SUBR;app3[cadr[j];evlis[cdr[e];b]]];
   [FEXPR;apply[cadr[j];list[cdr[e];b];b]];
   apply[cadr[j];evlis[cdr[e];b];b]]];
   &amp;[[j];search[b;
   &amp;[[j];eq[caar[j];car[e]]];
   &amp;[[j];apply[cadar[j];evlis[cdr[e];b];b]];
   &amp;[[j];error]]]];
   T -&gt; apply[car[e];evlis[cdr[e];b];b]]   
</pre>
The version published in the CACM-paper, March 1960:
<pre>apply[f;args] = eval[cons[f;appq[args]];NIL]

appq[m] = [null[m] -&gt; NIL;
       T -&gt; cons[list[QUOTE;car[m]];appq[cdr[m]]]]

eval[e;a] = [
  atom[e] -&gt; assoc[e;a];
  atom[car[e]] -&gt; [
  eq[car[e];QUOTE] -&gt; cadr[e];
  eq[car[e];ATOM] -&gt; atom[eval[cadr[e];a]];
  eq[car[e];EQ] -&gt; [eval[cadr[e];a] = eval[caddr[e];a]];
  eq[car[e];COND] -&gt; evcon[cdr[e];a];
  eq[car[e];CAR] -&gt; car[eval[cadr[e];a]];
  eq[car[e];CDR] -&gt; cdr[eval[cadr[e];a]];
  eq[car[e];CONS] -&gt; cons[eval[cadr[e];a];eval[caddr[e];
          a]]; T -&gt; eval[cons[assoc[car[e];a];
                                   evlis[cdr[e];a]];a]];
  eq[caar[e];LABEL] -&gt; eval[cons[caddar[e];cdr[e]];
                        cons[list[cadar[e];car[e]];a]];    
  eq[caar[e];LAMBDA] -&gt; eval[caddar[e];
               append[pair[cadar[e];evlis[cdr[e];a];a]]]

evlis[m;p] = [null[m] -&gt; NIL;
           T -&gt; cons[eval[car[m];a];evlis[cdr[m];a]]]
</pre>
<h2>Corrected Versions</h2>
A corrected version 1 (read ``funarg'' for ``closure'' if you want):
P-Lists are removed and the {\tt lambda}-case is introduced.
<pre>APPLY(F,L,A)=select(car(F);
          -1,app2(F,L,A);
          lambda,eval(caddr(F),append(pair(cadr(F),L),A));
          closure,eval(caddadr(F),append(pair(cadadr(F),L),
                                         caddr(F)));
          label,apply(caddr(F),L,append(pair(cadr(F),caddr
                           (F)),A));
          apply(eval(F,A),L,A))

EVAL(E,A)=select(car(E);
          -1,search(A,&amp;(J,caar(J)=E),&amp;(J,cadar(J)),error);
          const,cadr(E);
          label,eval(caddr(E),append(pair(cadr(E),caddr(E)),
                           A));
          lambda,list(closure,E,A);
          closure,E;
          apply(car(E),maplist(cdr(E),&amp;(J,eval(car(J),A))),A))

APP2(F,L,A)=select(F;caar,caar(L);cdr,cdar(L);cons,cons(car(L),cadr(L));
          list,L;null,car(L)=0;atom,caar(L)=-1;
          search(A,&amp;(J,caar(J)=F),
                   &amp;(J,(subrp(cadar(J)) -&gt; app3(F,L,A);
                        1 -&gt; apply(cadar(J),L,A))),
                   error))

evcon(E,A) = (E=0 -&gt; error,eval(caar(E),A) -&gt; eval(cadar(E),A),
              1 -&gt; evcon(cdr(E),A))
</pre>
Corrected version of second interpreter: computation of lambda-expressions 
is included -- a case for lambda-expressions in {\tt eval} is necessary now.
<pre>apply[f;args] = eval[combine[f;args]]

eval[e] = [
first[e]=NULL -&gt; [null[eval[first[rest[e]]]] -&gt; T;1 -&gt; F]
first[e]=ATOM -&gt; [atom[eval[first[rest[e]]]] -&gt; T;1 -&gt; F]
first[e]=EQ -&gt; eval[first[rest[e]]]]=eval[first[rest[rest[e]]]] -&gt; T;
     1 -&gt; F]
first[e]=QUOTE -&gt; first[rest[e]];
first[e]=FIRST -&gt; first[eval[first[rest[e]]]];
first[e]=REST -&gt; rest[eval[first[rest[e]]]];
first[e]=COMBINE -&gt; combine[eval[first[rest[e]]];eval[first[rest[rest
     [e]]]]];
first[e]=COND -&gt; evcon[rest[e]];
first[e]=LAMBDA -&gt; e;
first[first[e]]=LAMBDA -&gt; evlam[first[rest[first[e]]];first[rest[rest
     [first[e]]]];rest[e]];
first[first[e]]=LABEL -&gt; eval[combine[subst[first[e];first[rest
     [first[e]]];first[rest[rest[first[e]]]]];rest[e]]]];
1 -&gt; eval[combine[eval[first[e]],rest[e]]]]

evlam[vars;exp;args]=[null[vars] -&gt; eval[exp];1 -&gt; evlam[
     rest[vars];subst[first[args];first[vars];exp];rest[args]]]</pre>

</body></html>