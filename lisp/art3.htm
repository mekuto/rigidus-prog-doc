
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">


<title>GNU Common Lisp - часть 3, переменные и
константы</title>
<meta name="Microsoft Theme" content="blueprnt 0000, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body bgcolor="#FFFFFF" text="#003399" link="#3366FF" vlink="#9900FF" alink="#000066"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p></p>
<p>&nbsp;<img src="../../images/cartonarmy.gif" alt="[Картонная Армия - от галеры до ракеты!]" border="0" width="468" height="60">
</p>
<p>
<a href="../../index.htm"><img src="../../_derived/home_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Домой" align="middle"></a> <a href="../gcl.htm"><img src="../../_derived/up_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Вверх" align="middle"></a> <a href="../../toc.htm"><img src="../../_derived/toc.htm_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Содержание" align="middle"></a></p>
<p>
<img src="_derived/art3.htm_cmp_blueprnt000_bnr.gif" width="600" height="60" border="0" alt="Lisp - переменные">
<br>
<a href="art1.htm"><img src="_derived/art1.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - первые шаги" align="middle"></a> <a href="art2.htm"><img src="_derived/art2.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp -атомы и списки" align="middle"></a> <img src="_derived/art3.htm_cmp_blueprnt000_hbtn_p.gif" width="140" height="60" border="0" alt="Lisp - переменные" align="middle"> <a href="art4.htm"><img src="_derived/art4.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - вызов функций" align="middle"></a> <a href="art5.htm"><img src="_derived/art5.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Программные блоки" align="middle"></a> <a href="art6.htm"><img src="_derived/art6.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Структуры данных" align="middle"></a>
</p>
<p>&nbsp;</p>

<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Times New Roman">
<p>&nbsp;</p>
<p><a href="http://">
</a>
</p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Times New Roman">
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>
<div align="Right">
  <h4>В.Водолазкий<br>
  </h4>
   </div>
<h3>
   <br>
Common Lisp - переменные и константы</h3>
 
<div align="Justify"> 
<p>Поскольку часть объектов Лиспа используются для представления программ, 
нам не всегда предоставляется возможность поместить константу в программу 
путем простого объявления нового Лисп-объекта --- ведь вводимый объект может 
быть как константой, так и фрагментом самой программы. Для разрешения этой
 неоднозначности используется специальная форма <b>quote</b>.  Все переменные 
Common Lisp могут быть разделены на два больших класса --- простые переменные 
и имена функций. Между ними есть определенное сходство, а в ряде случаев для
их определения используются даже сходные средства (например, <b>boundp</b>
  и <b>fboundp</b>). Однако в большинстве случаев эти два вида переменных 
используются для решения совершенно разных задач: одни предназначены для обращения
к определенным в программе функциям, макросам и специальным формам, то есть
объектам, в которых хранится исполняемый код Лисп-программы, а вторые
-
для обозначения (и обращения) объектов, в которых хранятся данные.  </p>
 
<p>В соответствии с современными представлениями, с каждой функцией ассоциируется 
ее имя (некоторая конструкция <i>function-name</i>), которая может представлять 
собой либо символ, либо список из двух элементов, первым элементом которого 
является символ <b>setf</b>, а второй представляет собой собственно символ, 
обозначающий ссылку на определение функции.  Необходимость введения такого 
метода именования функции состоит в желании предоставить возможность гибкого 
расширения общих функций объектно-ориентированного расширения CLOS 
методами 
определенными пользователями. В частности, этот подход позволяет использовать
 для переопределения методов простую и привычную для начинающих функцию <b>
 setf</b>. Во многих случаях при разработке программ на  Common
Lisp, где 
необходимо передавать в качестве аргумента имя функции вы можете столкнуться 
с тем, что вместо символа от вас потребуют описанный выше двухэлементный список;
например, определение <b>defun</b> в ряде реализаций системы изменено так,
что вы можете записать <b>(defun (setf foo) ...)</b>, и специальная форма
<b>function</b> будет изменена таким образом, чтобы принимать любой список
вида <i>function-name</i>.<br>
  А в соответствии с традициями, любая функция вызванная, как <b>(setf 
f)</b>
 , должна вернуть одно единственное значение, которое равно ее первому аргументу, 
чтобы сохранить в силе спецификацию <b>setf</b>, в соответствии с которой 
эта функция возвращает новое значение установленной переменной.</p>
 
<p>Безусловно, стандарт Common Lisp не накладывает никаких ограничений на 
разработчиков, в части расширения синтаксиса имен функций, которые могут включать
списки, содержащие дополнительные символы, отличные от <b>setf</b>  и <b>
lambda</b>.</p>
 
<h3>  Ссылки  </h3>
 
<p>Значение обычной переменной может быть получено простым указанием ее имени 
в выполняемой форме. Интерпретация этого имени как обращения к специальной 
переменной или <i>лексической</i> переменной, определяется присутствием или 
отсутствием объявления <b>special</b>, относящегося к этому имени.  В Common 
Lisp предусмотрены также другие способы  доступа к значениям констант и переменных, 
реализованные с помощью описываемых ниже функций и специальных форм.</p>
 
<p><br>
 </p>
 
<h4>Специальная форма -  (quote object)</h4>
 
<p>Вызов <b>(quote  <i>x</i>)</b> всегда возвращает  <i>x</i>. Вычисление 
(оценка) значения <i>object</i> не производится, а поэтому он может представлять 
собой произвольный Лисп-объект, что позволяет ввести в программу на Лиспе 
константу, содержащую любую конструкцию.  Например:</p>
 
<p><font color="#000000">(setq a 43)<br>
(list a (cons a 3))                  ; (43
(43 . 3)) <br>
<br>
(list (quote a) (quote (cons a 3))   ; (a (cons a 3))<br>
<br>
</font></p>
 
<p>Поскольку формы <b>quote</b> используются очень часто, и набивать их название 
постоянно просто лень, для них еще три десятка лет назад было разработано 
ставшее общепринятым сокращение: любая форма 
<i>f</i>, перед которой следует 
знак апострофа,  интерпретируется как аргумент  функции <b>(quote  )</b>, 
которая как бы окружает  <i>f</i>, образуя конструкцию <b>(quote 
f)</b>.
  Например: </p>
 
<p><font color="#000000">(setq x '(the magic quote hack)) <br>
</font>
 </p>
 
<p>интерпретируется модулем чтения <b>read</b> как,</p>
 
<p><font color="#000000">(setq x (quote (the magic quote hack))) </font>
</p>
 
<h4>Специальная форма - ( function fn)  </h4>
 
<p>Значение вызова <b>function</b> всегда представляет собой интерпретацию <i>
  fn</i> как функции; иначе говоря  <i>fn</i> рассматривается так, как если 
бы было помещено на месте функционала в вызове функции. Это называется <i>
 функциональной блокировкой</i>. В частности, если <i>fn</i> представляет 
собой символ, возвращается ассоциируемое с ним определение функции. Если 
<i>fn</i> представляет собой lambda-выражение, возвращается сообщение о лексическом 
замыкании (``lexical closure''), которое означает, что при вызове этой функции 
тело lambda-выражения будет выполняться таким образом, как если бы значения 
всех свободных переменных, используемых в этой функции, остались теми же, 
что и на момент ее определения.  </p>
 
<p>Результат вызова специальной формы <b>function</b> всегда имеет тип <b>
 function</b>.  Это означает, что форма <b>(function <i>fn</i>)</b> может 
быть интерпретирована как <b>(the (function  <i>fn</i>))</b>.  При попытке 
применить <b>function</b> к символу, который не обозначает (в локальном или 
глобальном) контексте функцию, генерируется сообщение об ошибке. Например, 
не допускается использовать <b>function</b> по отношению к символам, обозначающим
 макросы или специальные формы. В ряде реализаций Common Lisp сообщение об 
ошибке в этих случаях не выдается (В сопроводительной документации это объясняется
``for performance reasons...''), но сам вызов все равно не обрабатывается. 
Иначе говоря, отсутствие сообщения об ошибке не означает, что вы получите 
ожидаемый результат.  </p>
 
<blockquote>   
  <p><small>В тех версиях Common Lisp, где имя функции может быть представлено 
двухэлементным списком  форма <b>function</b>
  может принимать любое имя функции, как в виде обычного символа, так и в 
виде такого списка. Поэтому допустимо использование
  <b>(function (setf cadr))</b> для обращения к расширению функции
  <b>
 setf</b> для <b>cadr</b>. 
В GNU Common Lisp это не работает</small>.   </p>
   </blockquote>
   
  <p>Вот несколько примеров:</p>
   
  <p><font color="#000000"> (defun adder (x) (function (lambda (y) (+ x y)))) <br>
  </font>
   </p>
   
  <p>Результатом вызова <b>(adder 3)</b> будет функция, которая будет добавлять 
число <b>3</b> к своему аргументу:</p>
   
  <p><font color="#000000">(setq add3 (adder 3))<br>
  (funcall add3 5)                 ;  8</font></p>
   
  <p><font color="#000099"><br>
   </font>Этот фрагмент оказывается работоспособным, поскольку<b> function</b>
  создает замыкание внутреннего lambda-выражения, что позволяет сослаться 
на значение <b>3 </b>переменной <b>x</b> даже после того как работа функции 
  <b>adder</b> будет завершена.</p>
   
  <p></p>
   
  <p>Вообще говоря, можно утверждать, что лексическое замыкание представляет 
собой сохранение возможность ссылаться на лексические связи, а не просто на
значения переменных. В самом деле,</p>
   
  <p><!--mstheme--></font><pre><font color="#000000">(defun two-funs (x)&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">  (list (function (lambda () x))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">     (function (lambda (y) (setq x y)))))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">     (setq funs (two-funs 6))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">     (funcall (car funs))&nbsp;                 &nbsp;; 6&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">     (funcall (cadr funs) 43)              ; 43&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">     (funcall (car funs))&nbsp;                 ; 43</font></pre><!--mstheme--><font face="Times New Roman">
   <br>
   
  <p>Функция <b>two-funs</b> возвращает список, содержащий две функции, каждая 
из которых сслыается на <b>связь</b> переменной <b>x</b>, созданной при обращении 
к <b>two-funs</b>, когда она была вызвана с аргументом <b>6</b>. Эта связь 
имеет вначале значение, равное <b>6</b>, однако <b>setq</b> может эту связь 
изменить. Лексическое замыкание, созданное для первого  lambda-выражения не
выполняет ``фиксирование'' значения <b>6</b> переменной <b>x </b>при создании 
замыкания. Вторая функция может изменить связь (в нашем случае, на <b>43</b>
 ) и это измененное значение становится доступным и первой функции тоже!</p>
   
  <p></p>
   
  <p>В тех ситуациях, когда замыкание lambda-выражения над одним и тем же 
набором связей может производиться многократно, полученные в результате замыкания 
могут быть  (А могут и не быть!) равны в смысле <b>eq</b>, в зависимости от
особенностей реализации системы.</p>
   
  <p>Например,</p>
   
   <!--mstheme--></font><pre><font color="#000000">(let ((x 5) (funs '()))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">  (dotimes (j 10)&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">    (push \#'(lambda (z)&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">             (if (null z) (setq x 0) (+ x z)))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">           funs))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">  funs)</font></pre><!--mstheme--><font face="Times New Roman">
   <br>
   
  <p>Результатом приведенного выше фрагмента станет список, содержащий десять 
замыканий. Каждое из них использует только связь с <b>x</b>. В каждом случае 
это одна и та же связь, поэтому все десять замыканий могут быть идентичными 
(по <b>eq</b>) объектами. Но с другой стороны, результатом выражения:</p>
   
<!--mstheme--></font><pre><font color="#000000">(let ((funs '()))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">  (dotimes (j 10)</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">     (let ((x 5))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">           (push (function (lambda (z)&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">                     (if (null z) (setq x 0) (+ x z))))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">              funs)))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">  funs)</font></pre><!--mstheme--><font face="Times New Roman">
   
  <p>также является список из десяти замыканий. Однако, в этом случае ни одно
из замыканий не равно другому в смысле <b>eq</b>, поскольку каждое из них
содержит отличную от других связь с <b>x</b>, и эти связи различаются по
своему поведению, поскольку используют вызов <b>setq</b>.</p>
   
  <p></p>
   
  <p>Вопрос уникальности поведения достаточно важен --- например, результатом 
более простого выражения</p>
   
  <p><!--mstheme--></font><pre><font color="#000000">(let ((funs '()))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">  (dotimes (j 10) </font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">         (let ((x 5))</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">              (push (function (lambda (z) (+ x z)))</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">                     funs)))&nbsp;</font></pre><!--mstheme--><font face="Times New Roman">
   <!--mstheme--></font><pre><font color="#000000">          funs)</font></pre><!--mstheme--><font face="Times New Roman">
   
  <p>будет список, содержащий десять замыканий, которые 
  <i>могут</i> оказаться 
попарно равны в смысле <b>eq</b>.  И хотя может показаться, что для каждого 
замыкания  образуются различные связи с <b>x</b> (а оно так и есть), эти связи
не могут быть распознаны как различные, поскольку их значения одинаковы, поскольку
применение <b>setq</b> по отношению к <b>x</b> отсутствует.  В результате
компилятор трансформирует это выражение в</p>
   
  <p><br>
  <font color="#000000">(let ((funs '()))<br>
  (dotimes (j 10)<br>
  (push (function (lambda (z) (+ 5 z)))<br>
  funs))<br>
  funs)<br>
  <br>
  </font>
   </p>
   
  <p>откуда явно следует использование одного и того же замыкания. Поэтому 
общее правило состоит в том, что Common Lisp вправе выбирать два различных 
механизма оценки для одной и той же формы \cd{function}. Первый, оптимизирующий 
механизм, сформирует идентичные в смысле  <b>eq</b> замыкания, если сумеет 
доказать, что концептуально различные замыкания на самом деле идентичны с 
точки зрения их поведения. Второй, строгий механизм, предусматривает создание 
в каждом случае нового замыкания не равного в смысле <b>eq</b> ни какому другому.Довольно
часто компилятор оказывается в состоянии доказать, что замыкание вовсе не
нуждается в закрытии связей с какими-либо переменными. Например:</p>
   
  <p><font color="#000000">(mapcar (function (lambda (x) (+ x 2))) y)<br>
  </font>
   <br>
   </p>
   
  <p>функция <b>(lambda (x) (+ x 2))</b> не содержит ссылок на какие-либо 
внешние объекты. В этом случае одно и то же замыкание может с успехом использоваться 
как значение для всех вызовов специальной формы <b>function</b>. В самом деле,
это значение просто не имеет смысла оформлять как лексическое замыкание ---
оно может представлять собой простую скомпилированную функцию, которая не
содержит (поскольку не нуждается) никакой информации о вычислительном (лексическом)
контексте.</p>
   
  <p>Поскольку формы <b>function</b> используются достаточно часто, для них 
придумано стандартное сокращение: любая форма <i> f</i> перед которой следуют 
знаки <b>#'</b> (<b>#</b> за которым следует апостроф) интерпретируется 
как аргумент <b>(function )</b>, то есть конструкция <b>(function 
  f)</b>
 .  Например:</p>
   
  <p><br>
  <font color="#000000">(remove-if&nbsp; #'numberp '(1 a b 3))<br>
  </font>
   <br>
  обычно воспринимается модулем чтения, как
   </p>
   
  <p><font color="#000000">(remove-if (function numberp) '(1 a b 3))<br>
  </font>
   <br>
   </p>
   
  <h4>Функция - (symbol-value symbol)</h4>
   
  <p>Функция <b>symbol-value</b> возвращает текущее значение динамической 
(специальной) переменной, обозначаемой с помощью</p>
   
  <p>символа <i>symbol</i>. Если переданный функции символ не имеет значения, 
то Лисп генерирует сообщение об ошибке.</p>
   
  <blockquote>     
    <p><small>Обратите внимание, что символы-константы на самом деле представляют 
собой переменные, значение которых не может быть </small><big><br>
     </big><small>изменено после их определения. Поэтому для получения значения 
именованных констант <b>symbol-value</b> может 
использоваться без </small><big><br>
     </big><small>каких-либо ограничений. А в случае, если<b>
  symbol-value</b> применяется к ключевому слову, то возвращается 
само слово.</small><big><br>
    <br>
     </big></p>
     </blockquote>
     
    <p>Функция <b>symbol-value</b> не обеспечивает доступа к значениям лексических 
переменных. Функция оказывается особенно полезной при реализации интерпретаторов 
языков, встроенных в Лисп-систему.  В части функций присваивания ей соответствует 
вызов <b>set</b>; впрочем, <b>symbol-value</b> может использоваться и с <b>
 setf</b>.</p>
     
    <h4>Функция<big> - (symbol-function symbol</big>)</h4>
     
    <p>Функция <b>symbol-function</b> возвращает текущее глобальное определение 
функции, ассоциируемой с символом <i>symbol</i>. Если символ не содержит определения
функции, Лисп генерирует сообщение об ошибке. Стоит иметь в виду, что определение
может быть как функцией, так и объектом, представляющим специальную форму
или макроопределение. Однако, в последнем случае попытка вызвать объект как
функцию приведет к ошибке. Если при разработке программы, например, при написании
интерпретатора, возникает необходимость единообразно обрабатывать макросы,
специальные формы и функции, то целесообразно вначале проверить тип символа
с помощью <b>macro-function</b> и <b>special-form-p</b>, а уже затем вызывать
его функциональное значение, но только в том случае если оба перечисленных
выше теста закончились неудачно (то есть вернули
    false).</p>
     
    <p>Функция особенно полезна при реализации интерпретаторов
    языков, встроенных 
в Лисп-систему.</p>
     
    <p>Функция <b>symbol-function</b> не обеспечивает доступа к значениям 
лексических имен функций, генерируемых с помощью</p>
     
    <p><b>flet</b> или <b>labels</b>; она может работать только с глобальными 
значениями (определениями) функций.</p>
     
    <p>Эти глобальные определения могут быть изменены с помощью применения 
    <b>setf</b> к результату <b>symbol-function</b>. Выполнение этой операции 
приводит к тому, что символу соответствует <i> единственное</i> глобальное 
определение функции; все предыдущие определения, независимо от того, были 
ли они макросами или функциями, теряются. При этом не допускается переопределение 
специальных форм.</p>
     
    <p>Поведение <b>symbol-function </b>в целом определяется типом функции, 
которую содержит ее аргумент.</p>
     
    <blockquote>       
      <!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
         
        <!--msthemelist--><tr><td valign="top" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">           
          <p>Функция <b>symbol-function</b> может вызываться с использованием 
в качестве аргумента любого символа, для которого предикат <b>fboundp</b>
  возвращает true. При этом стоит помнить, что <b>fboundp</b> возвращает
true для символов, ссылающихся на макросы или на специальные формы.</p>
         <!--mstheme--></font><!--msthemelist--></td></tr>
         
        <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">           
          <p>Если <b>fboundp</b> возвращает true, но ее аргумент представляет 
собой макрос или специальную форму, то значение функции <b>symbol-function</b>
  является неопределенным, однако <b>symbol-function</b> не генерирует сообщение 
об ошибке. </p>
         <!--mstheme--></font><!--msthemelist--></td></tr>
         
        <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">           
          <p>В тех случаях, когда <b>symbol-function</b> используется совместно 
с <b>setf</b>, новое значение должно иметь тип <b>function</b>. Не допускается 
присваивать результат применения  <b>symbol-function</b> символу, списку или
значению, возвращенному <b>symbol-function</b> после применения к макросу 
или специальной форме.</p>
         <!--mstheme--></font><!--msthemelist--></td></tr>
       
      <!--msthemelist--></table><!--mstheme--><font face="Times New Roman">
       
       </blockquote>
       
      <h4 align="left">Предикат - (boundp symbol)</h4>
       
      <p>Предикат <b>boundp</b> возвращает true, если динамическая (специальная) 
переменная <i> symbol</i> имеет значение; ы противном</p>
       
      <p>случае возвращается false.</p>
       
      <h4>Предикат - (fboundp symbol)</h4>
       
      <p>Предикат <b>fboundp</b> возвращает true, если переданный ему аргумент 
имеет глобальное определение функции. При этом <b>fboundp</b> возвращает true
и в тех случаях, когда переданный ему символ ссылается на макрос или на специальную
форму. Для выявления (различения) этих случаев могут быть использованы тесты
      <b>macro-function</b> и <b>special-form-p</b>.</p>
       
      <h4>Предикат - (special-form-p symbol)</h4>
       
      <p>Аргументом предиката <b>special-form-p</b> является символ. Если 
этот символ содержит определение специальной формы, то возвращается значение 
отличное от false, в противном случае возвращается false.</p>
       
      <p>Эта оговорка весьма существенна --- обычно, отличное от nil значение 
представляет собой функцию, которая может быть использована для интерпретации 
(оценки значения) специальной формы, однако в целом возвращаемое значение 
зависит от версии Common Lisp.</p>
       
      <p>При этом допускается, что для некоторого символа как  <b>special-form-p</b>
 , так и <b>macro-function</b> вернут true. Так происходит в тех случаях, 
когда макрос, для повышения производительности системы реализуется также и
как макрос. С другой стороны, макроопределение должно быть доступно для использования
программами, которые воспринимают только стандартные специальные формы, </p>
       
      <h3>Присвоение значений</h3>
       
      <p>  Рассматриваемые ниже средства позволяют установить переменной новое
значение, или говоря, более точно, изменить значение, ассоциируемое с текущей
связью некоторого символа).  <br>
       </p>
       
      <h4>Специальная форма - (setq var form)  </h4>
       
      <p>Специальная форма <b>(setq var1 form1 var2 form2 ...)</b> представляет 
собой ``простой оператор присвоения значений переменным''. При его выполнении 
прежде всего оценивается значение  <i>form1</i>, и затем результат сохраняется 
в переменной  <i>var1</i>, затем оценивается  <i>form2</i> и результате ее 
выполнения сохраняется в  <i>var2</i>, и так далее... Переменные представляются 
как символы и интерпретируются как обращения к статическим или динамическим 
экземплярам, в соответствии с обычными правилами. Это позволяет использовать 
      <i>s</i><b><i>etq</i></b> для присвоения значений не только обычным, 
но также лексическим и специальным переменным.  </p>
       
      <p>Функция <b>setq</b> возвращает последнее присвоенное значение, то
 есть результат оценки последнего аргумента. Ну и в самом крайнем случае, 
форма <b>(setq)</b> также допустима и возвращает
      false. Функция должна иметь 
четное количество аргументов. Например, в фрагменте  </p>
       
      <p><br>
      <font color="#000000"> (setq x (+ 3 2 1) y (cons x nil))<br>
      </font>
       <br>
       <b>x</b> устанавливается равным 6, <b>y</b> --- также равным (6), 
и само значение <b>setq</b> равно (6). Обратите внимание, что первое присвоение 
выполняетося до того, как начнет выполняться второе, что позволяет использовать 
уже вычисленные значения.
       </p>
       
      <blockquote>         
        <p><small>См. также описание <b>setf</b>
 , которая считается ``главным оператором присвоения значений'' в Common
Lisp, и способна присваивать значения переменным, элементам массивов и т.д.<br>
 </small></p>
         </blockquote>
         
        <h4>Макрос -- ( psetq var form)</h4>
         
        <p>Форма <b>psetq</b> в целом аналогична форме <b>setq</b>, за исключением 
того, что все привоения осуществляются одновременно (параллельно). Вначале 
осуществляется оценка значений всех форм, а уже затем проводится назначение 
этих значений переменным. Сама форма <b>psetq</b> возвращает false. Например:</p>
         
        <p><br>
        <font color="#000000">(setq a 1)<br>
        (setq b 2)<br>
        (psetq a b  b a)<br>
        a                     ; 2<br>
        b                     ; 1<br>
        <br>
         <br>
        </font>
         </p>
         
        <p>В этом примере значения <b>a</b> и <b>b</b> в результате параллельного 
присвоения меняются друг с другом. (В случае, елси одновременно нужно назначить 
несколько значений переменных, имеет смысл использовать конструкцию <b>do</b>
 ).</p>
         
        <h4>Функция - (set symbol value)</h4>
         
        <p>Функция <b>set</b> позволяет измеенить значение динамической (специальной) 
переменной и приводит к тому, что переменная, адресуемая с помощью <b>symbol</b> назначается в качестве значения  value. При этом 
значение может представлять собой произвольный объект Лиспа. </p>
         
        <p>Изменению подлежит только текущая динамическая связь. Если до этого
не было установлено ни одной свзяи, изменется глобальное значение. Например:</p>
         
<!--mstheme--></font><pre><font color="#000000">(set (if (eq a b) 'c 'd) 'foo)</font></pre><!--mstheme--><font face="Times New Roman">
         
        <p>приведет либо к установке <b>c</b> в <b>foo</b>, либо к установке 
        <b>d</b> в <b>foo</b>, в зависимости от результатов проверки <b>(eq 
a b)</b>.</p>
         
        <p><b>set</b> возвращает в качестве результата  
        <i>value</i>.</p>
         
        <p><b>set</b> не может изменить значение локальной (лексически связанной) 
переменной. Для изменения значений переменных в программах обычно используется 
специальная форма <b>setq</b>. Функция <b>set</b> особенно полезна при разработке 
интерпретаторов языков, встраиваемых в Лисп.</p>
         
        <h4>Функция - (makunbound symbol)</h4>
         
        <p>Функция <b>makunbound</b> отторгает значение, связываемое с переменной 
        <i>symbol</i>, в результате чего оно приобретает статус
        ``unbound'' - несвязанной переменной, которая не имеет никакого значения. Функция <b>
 fmakunbound</b> осуществляет аналогичную операцию по отношению к глобальному 
определению функции, ассоциируемой с символом <i>symbol</i>.</p>
         
        <p>Например:</p>
         
        <p><br>
        <font color="#000000">(setq a 1)<br>
 a  ;  1<br>
        (makunbound 'a)<br>
 a  ;  Ошибка!<br>
        <br>
        (defun foo (x) (+ x 1))<br>
        (foo 4)            ;  5<br>
        (fmakunbound 'foo)<br>
        (foo 4)  ; Ошибка!<br>
        </font><br>
         <br>
 Обе функции возвращают в результате работы  {\it symbol}.<br>
  </p>
         
        <h3>Обобщенные переменные  </h3>
         
        <p>В языке Лисп любая переменная может содержать ссылку на один единственный 
фрагмент данных, который представляет собой объект Лиспа. Основные операции, 
которые могут выполняться над переменными, состоят в извлечении этого объекта 
и присвоении в качестве значения переменной нового объекта взамен старого; 
эти действия часто называются операциями <i>доступа</i> и <i>обновления</i>
 . Однако, сама концепция переменных, доступ к
        которым осуществляется через 
символы, может быть расширена (обобщена) таким образом, чтобы обеспечить доступ
к любым областям (ячейкам) памяти, которые могут использоваться для  хранения
определенных фрагментов данных, вне зависимости от того, как эта область
именована. Примерами таких областей могут служить <b>car</b> и 
        <b>cdr</b>
 части cons-ячеек, элементы массивов, и компоненты структур.  </p>
         
        <p>Для каждого из типов обобщенных переменных обычно обычно реализованы 
две функции, предназначенные для выполнения операций чтения и записи их значений. 
Так для переменной обычное упоминание ее имени означает выполнение операции 
чтения ее значения, а специальная форма <b>setq</b>, примененная к ней, может 
быть использована для обновления значения. Функция <b>car</b> позволяет прочитать 
        <i>car</i>-часть  cons-ячейки, а функция <b>rplaca</b> присваивает 
ей новое значение. Аналогичным образом, <b>symbol-value</b> осуществляет доступ
(чтение) к динамическому значению переменной, связываемой с некоторым символом,
а вызов функции <b>set</b> позволяет это значение изменить.  </p>
         
        <p>С практической точки зрения удобнее отказаться от концепции двух
 различных, независимых функций --- вместо этого мы будем рассматривать вызов 
функции доступа с заданными аргументами просто как обращение к имени <i>name</i>
 , представляющему собой идентификатор местоположения
        переменной в массиве 
памяти, доступном Лисп-системе. В результате запись <b>x</b> мы можем рассматривать 
как имя переменной (адрес в памяти), а <b>(car x)</b> --- как имя <i> car</i>
 -части некоей cons-ячейки, которая, в свою очередь, может быть идентифицирована 
с помощью <b>x</b>. Теперь, вместо того, чтобы утруждать мозги запоминанием
 двух функций для каждого типа обобщенных переменных, мы будем использовать
 единообразный армейский подход как в части доступа к значениям переменных 
(по имени), так и в части присвоения им новых значений --- с помощью макроопределения 
        <b>setf</b>. По большому счету это аналогично тому подходу, который 
используется при применении специальной формы <b>setq</b> для преобразования 
имени переменной в форму, которая присваивает
        этой переменной новое значение.
 Доказать простоту и универсальность этого подхода нам поможет следующая
таблица:   </p>
         
        <!--mstheme--></font><table cellpadding="2" cellspacing="2" border="1" width="100%" bordercolordark="#003399" bordercolorlight="#003399">
           <tbody>
             <tr>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>Функция доступа</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>Функция обновления</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>Обновление с помощью <b>setf</b></p>
               <!--mstheme--></font></td>
             </tr>
             <tr>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>x</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(setq x datum)</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(setf x  datum)</p>
               <!--mstheme--></font></td>
             </tr>
             <tr>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(car x)</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(rplaca x datum)</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(setf (car x) datum)</p>
               <!--mstheme--></font></td>
             </tr>
             <tr>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(symbol-value x)</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(set x datum)</p>
               <!--mstheme--></font></td>
               <td valign="Top"><!--mstheme--><font face="Times New Roman">               
              <p>(setf (symbol-value x) datum)</p>
               <!--mstheme--></font></td>
             </tr>
           
          </tbody>         
        </table><!--mstheme--><font face="Times New Roman">
         
        <p> Как уже упоминалось выше, <b>setf</b> представляет собой макрокоманду, 
которая проверяет тип формы доступа к переменной,
        определяет, исходя из этого 
тип самой переменой, и затем осуществляет вызов соответствующей функции обновления 
значений.  </p>
         
 После введения в Common Lisp макроса <b>setf</b>, использование конструкций 
        <b>setq</b>, <b>rplaca</b> и <b>set</b> уже не является обязательным 
--- некоторые экстремисты даже рассматривают их как избыточные. Однако эти 
функции сохранены в Common Lisp не только ``в целях поддержания исторических 
традиций''. Во-первых, они необходимы для упрощения переносимости кода с других
версий Лиспа. Во-вторых, в огромном числе случаев они выполняются быстрее, 
чем аналогичный вызов <b>setf</b>. И наконец, ``универсальный
присваиватель'' 
        <b>setf</b> сам использует эти функции внутри своего определения! 
С другой стороны, значительная часть других функций присваивания, таких как, 
например, <b>putprop</b>, представляющая собой функцию для записи свойств,
полученных посредством <b>get</b>, исключена из Common Lisp, поскольку вместо 
нее теперь используется <b>setf</b>.  <br>
         
        <h4>Макрос - (setf place newvalue)  </h4>
         <br>
 Макрос <b>(setf  place  newvalue)</b> использует форму <i> place</i>, которая 
позволяет прочитать значение некоторого объекта данных, для синтеза формы,
 позволяющей установить этому объекту новое значение и выполняет вновь сгенерированную 
форму с передачей ей <i>newvalue</i>. Для простоты можно считать, что вызов 
        <b>setf</b> расширяется в форму обновления данных,
которая сохраняет 
результат оценки формы <i>newvalue</i> в месте, на которое ссылается форма <i>
  place</i>.                
        <p>В случае, если при вызове указано больше одной пары place-newvalue, 
эти пары обрабатываются последовательно.</p>
        <p>         </p>
        <p>И с целью обеспечения полноты области определения макроса,допускается
использование <b>(setf)</b>, который просто возвращает <b>nil</b>.</p>
В макросе <b>setf</b>  прилагается немало усилий к тому, чтобы сохранить традиционный
порядок оценки субформ ``слева-направо''. С другой стороны, конкретный вид
расширения некоторой формы ничем не гарантируется, и даже может зависеть
от реализации Лиспа; единственное, что можно утверждать, это то, что расширение
формы <b>setf</b> будет представлять собой форму обновления данных, которая
будет работать в данной реализации системы, и при этом будет сохранен порядок
оценки субформ ``слева-направо''.<br>
        <br>
Главный результат оценки формы <b>setf</b> состоит в получении значения 
<i>newvalue</i>. Поэтому <b>(setf (car x) y)</b> не расширяется в
конструкцию <b>(rplaca x y)</b>, но представляет собой что-нибудь вроде<br>
<font color="#000099"><br></font><font color="#000000">(let ((G1 x) (G2 y)) (rplaca
G1 G2) G2)<br></font><br>
Конечно, точная реализация расширения зависит от реализации системы. Вы всегда
можете пощупать, что происходит на самом деле с помощью <b>macroexpand</b>
. Кроме того, пользователь может определить новые расширения <b>setf</b>
с помощью <b>defsetf</b>. <br>
<p>К числу дополнительных средств, обеспечивающих работу с обобщенными
переменными относятся макросы</p>
        <b>getf, remf, incf,  decf,  push, pop assert, ctypecase</b> и<b>
 ccase</b>.<br>
<p>
При этом все эти макросы должны гарантировать
соблюдение ими правил ``очевидной''
семантики: субформы ссылок на обобщенные переменные оцениваются ровно столько
раз, сколько они встречаются в исходных текстах программы, и оценка производится
точно в том же порядке, в котором они появляются в программе.<br>
</p>
В некоторых макросах, использующих ссылки на обобщенные переменные, таких
как <b>shiftf, incf, push</b>, и <b>setf</b> обобщенная переменная используется
как для чтения, так и для записи. Поэтому сохранение принятого в исходной
программе порядка оценки значения и количества этих оценок оказывается исключительно
важным для обеспечения правильной работы разрабатываемого программного кода.<br>
        <br>
        <blockquote><small>В качестве примера использования этих семантических
правил, укажем, что в ссылке на обобщенную переменную
          <b>(setf
reference value)</b> форма  value будет оцениваться <i>
после</i> всех субформ в <i> reference</i>
, поскольку появляется справа (то есть позже) от нее.<br>
 </small></blockquote>
Расширение этих макросов должно содержать код, который следует<small> </small>
описанным выше правилам. Это достигается путем применения вполне очевидного
решения --- введения временных переменных, связанных с субформами, адресующими
используемые обобщенные переменные. По мере расширения макроса, когда в дело
вступает (если он используется) оптимизатор, эти временные переменные могут
быть исключены, если оптимизатору удастся доказать, что их отсутствие не
оказывает влияние на генерируемый программный код. Например, нет никакого
смысла помещать во временную переменную значение константы. Точно так же,
переменная или любая форма, которая не имеет никаких побочных эффектов, так
же не нуждается в помещении во временную переменную, если можно доказать,
что ее значение не изменяется при изменении значений обобщенной переменной.<br>
<p>
В большинстве версий Common Lisp реализованы встроенные средства, осуществляющие
такого рода упрощения генерируемого кода.  поскольку эти средства самостоятельно
следят за соблюдением описанных выше семантических правил, пользователь может
не беспокоиться о соблюдении этих правил, что заметно облегчает жизнь при
разработке сложных программ. <br>
          <br>
Примером такой оптимизации может служить следующий фрагмент:</p>
          <p><br><font color="#000000">(incf (ldb byte-field variable))<br></font><br><br>
Этот вызов макроса будет расширен (в зависимости от версии) в конструкцию
вида:<br>
          <br><font color="#000000">(setq variable&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (dpb (1+ (ldb byte-field variable))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          byte-field&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          variable))<br><br></font><br>В этом примере мы проигнорирем все сложности связанные с возвращением
корректного значения, которое представляет собой инкрементированный на единичку
байт, а вовсе не новое значение <b>variable</b>. Заметьте, что переменная
          <b>byte-field</b> оценивается дважды, а на переменную <b>variable</b>
 вообще ссылаться приходиться целых три раза!</p>
          <p>Теперь рассмотрим фрагмент:</p>
          <p><br><font color="#000000">(incf (ldb (aref byte-fields (incf
          i))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (aref (determine-words-array) i)))<br></font><br>который должен расшириться в конструкцию:</p>
          <!--mstheme--></font><pre><font color="#000000">

(let ((temp1 (aref byte-fields (incf i))) 
      (temp2 (determine-words-array))) 
  (setf (aref temp2 i) 
      (dpb (1+ (ldb temp1 (aref temp2 i))) 
         temp1 
          (aref temp2 i))))
</font>
</pre><!--mstheme--><font face="Times New Roman">
  вновь мы игнорируем сложности, связанные с возвращением корректного значения.
Что нам действительно важно, так это то, что выражения <b>(incf i)</b> и
          <b>(determine-words-array)</b> не должны дублироваться, поскольку
оба могут иметь побочный эффект, либо на них могут воздействовать побочные
эффекты от применения других функций.<br>
<p>
В целом, код, полученный в результате макрорасширения формы <b>setf</b>,
которая принимает в качестве аргумента ссылку на обобщенную переменную, должен
выполнять три основных операции:
<p>&nbsp;</p>
          <!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Осуществляется оценка субформ, которые формируют значения
в направлении слева-направо, а затем полученные значения присваиваются временным
переменным; эта операция называется  <i>временным связыванием</i>.<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Производится считывание значения обобщенной переменной, с
использованием переданной макросу формы доступа, и получается текущее (старое)
значение этой переменной; эта операция называется 
              <i>выполнением доступа</i>
. Надо иметь в виду, что эта операция выполняется после того, как завершены
все оценки, производящиеся на предыдущем шаге, включая все возможные побочные
эффекты, к которым это могло привести. <!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">  Осуществляется связывание сохраненной переменной с новым
значением, а затем присвоение этого значения обобщенной переменной с использованием
переданной макросу формы обновления. Эта операция называется 
              <i>записью
переменной</i>.<!--mstheme--></font><!--msthemelist--></td></tr>
          <!--msthemelist--></table><!--mstheme--><font face="Times New Roman">
При этом осуществление доступа к обобщенной переменной, в общем случае не
является частью последовательности оценок, которые должны выполняться слева-направо.<br>
          <br>
Формы, используемые для указания адресов переменных, такие как  <b>ldb</b>
, <b>mask-field</b> и <b>getf</b> допускают использование в качестве аргументов
других идентификаторов <i>place</i>. Поэтому при выполнении макрорасширения
          <b>setf</b> в этих формах, необходимо обязательно вызывать <b>get-setf-method</b>
, чтобы определить, как должна быть интерпретирована вложенная обобщенная
переменная.<br>
<br>В формах вида<br><br><font color="#000000"><br>(setf (ldb
byte-spec&nbsp; place-form) newvalue-form)<br><br></font><br>
адрес переменной извлекается из <i>place-form</i>. При этом функция обновления
переменной также задается формой <i>place-form</i>, а не объектом типа <b>
integer</b>. Поэтому вызов <b>setf</b> должен генерировать код, который выполняет
следующие операции:<br>
<br>
          <!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Оценка значения <i>byte-spec</i> и его связь с временной
переменной;<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Временное связывание для <i>place-form</i>;<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Оценка значения <i>newvalue-form</i> и связывание его со
внутренней переменной;<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Осуществление доступа к <i>place-form</i>;<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Выполнение сохранения нового значения в <i>place-form</i>
, где заданное битовое поле считанного целого числа заменяется значением
сохраненной переменной.<!--mstheme--></font><!--msthemelist--></td></tr>
          <!--msthemelist--></table><!--mstheme--><font face="Times New Roman">
          <!--mstheme--></font><pre>
</pre><!--mstheme--><font face="Times New Roman">
Из этого примера следует, что сами по себе семантические правила работы с
обобщенными переменными, вещь хотя и понятная, но достаточно утомительная
при ее самостоятельной реализации. Кроме того, существует еще несколько
тонкостей, которые заметно усложняют жизнь <br>
          <br>
          <!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Встроенные макросы, такие как <b>setf</b> и <b>push</b>,
которые самостоятельно соблюдают правила семантики.<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Макрос <b>define-modify-macro</b>, который позволяет заметно
упростить процедуру создания новых макросов, обслуживающих<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">обобщенные переменные. При этом автоматически обеспечивается
соблюдение всех семантических правил.<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Макрос <b>defsetf</b>, который позволяет легко объявлять
новые типы ссылок на обобщенные переменные. При его использовании все семантические
правила также соблюдаются автоматически.<!--mstheme--></font><!--msthemelist--></td></tr>
            <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Макрос <b>define-setf-method</b> и функция <b>get-setf-method</b>
, которые осуществляют доступ ко внутренним
              механизмам Лиспа, в тех случаях,
когда необходимо определить новый сложный тип обобщенной переменной или ориентированный
на работу с такой переменной макрос.<!--mstheme--></font><!--msthemelist--></td></tr>
          <!--msthemelist--></table><!--mstheme--><font face="Times New Roman">
          <!--mstheme--></font><pre>
</pre><!--mstheme--><font face="Times New Roman">
          <h4>Макрос - (define-modify-macro name lambda-list function [doc-string]
)</h4>
Этот макрос определяет макрос вида ``чтение-модификация-запись'' с названием
          <i>name</i>. Примером такого макроса может служить
хорошо известный
          <b>incf</b>. Первая субформа сгенерированного макроса будет представлять
собой ссылку на обобщенную переменную. Функция <i>function</i> представляет
собой полное описание функции, которое должно быть применено к старому содержимому
обобщенной переменной для получения нового значения; этот аргумент, по вполне
понятным причинам не оценивается.<br>
<p>
Список <i>lambda-list</i> описывает остальные переменные функции <i>function</i>
; эти аргументы будут передаваться функции из оставшихся субформ макро, следующих
после обращения к обобщенной переменной. Список <i>lambda-list</i> может
содержать маркеры <i>&amp;optional</i> and <i>&amp;rest</i>. Однако, использование
маркера <i>&amp;key</i> не допускается, для целей, преследуемых при использовании
вызова <b>define-modify-macro</b> вполне достаточно маркера <i>&amp;rest</i>
. И последним, необязательным аргументом <i>doc-string</i> является строка
документации, описывающая работу с макросом 
<i>name</i>.</p>
          <p>С помощью этого макроса мы можем определить макрос <b>incf</b>
 как:</p>
          <p><br><font color="#000000">(define-modify-macro incf (&amp;optional
          (delta 1)) +)<br></font><br>
Или, вот пример полезного макроса, который не входит в число входящих в стандартную
библиотеку  Common Lisp:<br>
          <br><font color="#000000">(define-modify-macro unionf (other-set
          &amp;rest keywords) union)</font><font color="#000099"><br></font><br>Надеюсь, что я не слишком уморил читателя обсуждением тонкостей
установки значений переменных в Лиспе. Но увы, без подобной теоретической
подготовки не обойтись никак. Ведь примеры постепенно становятся все сложнее,
а отвлеккаться каждый раз на обсуждение методов доступа  или извлечению свойств
очень не хочется. Поэтому я полагаю, что этот материал будент воспринят вами
благосклонно. В следующий раз мы обсудим,
          как же на самом деле в Лиспе производится
вызов функции и как можно "предсказать", читая
          текст программы, какое же
из значений, формируемых в ходе вычислений, будет возвращено в результате
вычислений.</p>
          <p> </p>
          </div>


      <p> &nbsp; </p>
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>



      <p> &nbsp; </p>
&nbsp;
<!-- SpyLOG f:0211 -->
<script language="javascript"><!--
Mu="u4689.42.spylog.com";Md=document;Mnv=navigator;Mp=1;
Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();
Mt=(new Date()).getTimezoneOffset();
Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;
My="";
My+="<a href='http://"+Mu+"/cnt?cid=468942&f=3&p="+Mp+"&rn="+Mrn+"' target='_blank'>";
My+="<img src='http://"+Mu+"/cnt?cid=468942&"+Mz+"&r="+escape(Md.referrer)+"&pg="+escape(window.location.href)+"' border=0  width=88 height=31  alt='SpyLOG'>";
My+="</a>";Md.write(My);//--></script><noscript>
<a href="http://u4689.42.spylog.com/cnt?cid=468942&f=3&p=1" target="_blank">
<img src="http://u4689.42.spylog.com/cnt?cid=468942&p=1" alt='SpyLOG' border='0'  width=88 height=31 >
</a></noscript>
<!-- SpyLOG  --><!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p>
<script type="text/javascript"><!--
var yandex_r = Math.round(Math.random() * 100000);
document.write('<sc'+'ript type="text/javascript" src="http://an.yandex.ru/code/14812?rnd=' + yandex_r + '&direct-style=2&direct-limit=4&market-style=0&market-limit=4"></'+'sc'+'ript>');
//--></script>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h5>Послать письмо <a href="mailto:voldemarus@narod.ru">
voldemarus@narod.ru</a> &nbsp;<br>
Авторские права © 2003-2009
Картонная армия<br>
Последнее изменение:
января 09, 2010</h5>
<p></p>
<p></p>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>


