
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">


<title>GNU Common Lisp - часть 4, вызов функций</title>
<meta name="Microsoft Theme" content="blueprnt 0000, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body bgcolor="#FFFFFF" text="#003399" link="#3366FF" vlink="#9900FF" alink="#000066"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p></p>
<p>&nbsp;<img src="../../images/cartonarmy.gif" alt="[Картонная Армия - от галеры до ракеты!]" border="0" width="468" height="60">
</p>
<p>
<a href="../../index.htm"><img src="../../_derived/home_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Домой" align="middle"></a> <a href="../gcl.htm"><img src="../../_derived/up_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Вверх" align="middle"></a> <a href="../../toc.htm"><img src="../../_derived/toc.htm_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Содержание" align="middle"></a></p>
<p>
<img src="_derived/art4.htm_cmp_blueprnt000_bnr.gif" width="600" height="60" border="0" alt="Lisp - вызов функций">
<br>
<a href="art1.htm"><img src="_derived/art1.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - первые шаги" align="middle"></a> <a href="art2.htm"><img src="_derived/art2.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp -атомы и списки" align="middle"></a> <a href="art3.htm"><img src="_derived/art3.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - переменные" align="middle"></a> <img src="_derived/art4.htm_cmp_blueprnt000_hbtn_p.gif" width="140" height="60" border="0" alt="Lisp - вызов функций" align="middle"> <a href="art5.htm"><img src="_derived/art5.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Программные блоки" align="middle"></a> <a href="art6.htm"><img src="_derived/art6.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Структуры данных" align="middle"></a>
</p>
<p>&nbsp;</p>

<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Times New Roman">
<p>&nbsp;</p>
<p><a href="http://">
</a>
</p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Times New Roman">
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>
<div align="Right">
  <h4>В.Водолазкий<br>
  </h4>
   </div>


<h2 align="center">Вызов функций</h2>


<p align="center">&nbsp;</p>

Наиболее простая, примитивная форма вызова функции в Лисп-системе
вообще не может быть выражена словами - она просто не имеет
имени. В самом деле, любой список, который не имеет какой-либо
другой интерпретации как макровызова, или специальной формы,
считается вызовом функции. Однако, в Лиспе есть и другие
конструкции, которые используются реже, но все же необходимы в
достаточно большом количестве практических случаев.

<h4>apply function arg &amps;rest more-args</h4>

Задача <code>apply</code> состоит в применении функции <i>function</i> к
списку аргументов. При этом функция может представлять собой
скомпилированный объект кода, представлять собой лямбда-выражение
или символ.

<quote>
<p><font size=-1>
&nbsp;В последние годы в ряде реализаций Common Lisp не допускается
использовать в качестве аргумента apply старые добрые
лямбда-выражения. Однако это ограничение легко обходится -
достаточно использовать аббревиатуру</p>
 <!--mstheme--></font><pre><font color="#000000">#'</font></pre><!--mstheme--><font face="Times New Roman"> перед началом
выражения, которое введено в явном виде, и все будет в порядке.
</font></quote>
<p>
Аргументы, передаваемые <i>function</i> образуются из последнего
аргумента <b>apply</b>, которые с помощью <b>append</b> дописываются
в конец вызова функции. Фактически, создается список аргументов,
который и передается функции для обработки.
Например:
<!--mstheme--></font><pre>
<font color="#000000">(setq f '+) (apply f '(1 2))        ; 3 
(setq f #'-) (apply f '(1 2))       ; -1 
(apply  #'max 3 5 '(2 7 3))         ; 7 
(apply 'cons '((+ 2 3) 4))          ; ((+ 2 3) . 4)  а не (5 . 4) 
(apply #'+ '())                     ; 0
</font></pre><!--mstheme--><font face="Times New Roman"><p>
Обратите внимание, что если функция использует ключевые
аргументы, то в списке аргументов должны присутствовать и ключи,
и соответствующие им значения:
<!--mstheme--></font><pre>
<font color="#000000">(apply #'(lambda (\cd{\&amp;key} a b) (list a b)) '(:b 3)) ; (nil 3)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Это может оказаться весьма полезным при использовании
режима &amp;allow-other-keys:
<!--mstheme--></font><pre><font color="#000000">
(defun foo (size &amp;rest keys &amp;key double &amp;allow-other-keys) 
  (let ((v (apply #'make-array size :allow-other-keys t keys))) 
     (if double (concatenate (type-of v) v v) v))) 
 
(foo 4 :initial-contents '(a b c d) :double t) 
                ; -&gt;  #(a b c d a b c d)
</font></pre><!--mstheme--><font face="Times New Roman">


<h4>funcall fn &rest arguments</h4>

Функция (funcall <i> fn  a1 a2 ...  an</i>)
применяет функцию <i>fn</i> к аргументам <i> a1,  a2, ..., an</i>.
При этом <i>fn</i> не может представлять собой макрос или
специальную форму, поскольку никакого смысла в таком вызове
просто быть не может.
<p>
Так же, как и в случае <b>apply</b>, обработка лямбда-выражений
осуществляется с помощью специальной аббревиатуры <code>#'</code>,
которая представляет собой сокращенное описание вызова
<b>function</b>.
<p>
Например:<!--mstheme--></font><pre>
<font color="#000000">(cons 1 2) ==&gt; (1 . 2) 
(setq cons (symbol-function '+)) 
(funcall cons 1 2) ==&gt; 3
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Отличие между <b>funcall</b> и обычным вызовом функции состоит в
том, что сама функция получается в результате обычной оценки
потока <i>данных</i>, а не в результате стандартной интерпретации
функции, описание которой заранее определено в программе. 
<p>
В этом отношении <b>funcall</b> является отражением реально
существующего в Лиспе единства программ и данных --- ничто не
мешает вам сгенерировать код программы в самой программе и тут же
его использовать для получения новых функций. Одним словом, вот
она - реальная предпосылка для вполне реального искусственного
интеллекта (А заодно и реализационная основа для создания
Лисп-вирусов...).


<h4>Константа call-arguments-limit</h4>

Значение константы <b>call-arguments-limit</b> представляет собой
положительное число, представляющее собой максимальное количество
аргументов, которое может быть передано функции. Это значение
зависит от реализации системы и, например, для GNU Common Lisp
оно равно 64. Значение этой переменной должно быть не меньше
<b>lambda-parameters-limit</b> (в GCL также равна 64). 

<h2>Последовательные вычисления</h2>

Каждая из описываемых в данном параграфе конструкций просто
осуществляет последовательную оценку своих аргументов, которые
представляют собой формы. Однако возвращаемые ими результаты
отличаются, и именно этот факт будет представлять для нас интерес.

<h4>Специальная форма progn </h4>

Конструкция <b>progn</b> принимает в качестве аргументов несколько форм и
последовательно, слева направо, оценивает их значения. Результаты
всех вычислений, кроме последнего, отбрасываются, а значение
последней вычисленной формы становится значением всей конструкции
<b>progn</b>. Можно считать, что все формы кроме последней
вызываются исключительно ради производимых
ими побочных
эффектов, а последняя --- ради возвращаемого ей значения.
<p>
Форма progn представляет собой одну из элементарных
управляющих структур, предназначенных для формирования так
называемых ``составных операторов'', аналогами которых в
процедурных языках программирования являются, например, блоки
begin-end.
<p>
Стоит заметить, что многие из конструкций Лиспа на самом деле
представляют собой неявные progn-формы, поскольку их
синтаксис позволяет включить в качестве аргументов несколько
(или вернее сказать, произвольное количество) форм, значения
которых затем вычисляются последовательно, одна за другой, а
затем в качестве результата используется значение только
последней формы.<p>
Если последняя форма, входящая в вызов <b>progn</b> возвращает
несколько значений, то и сама форма <b>progn</b> возвращает все эти
значения. Если внутри блока <b>progn</b> не оказалось ни одной
формы, то в качестве результата будет возвращено
NIL.
Эти правила верны и для неявных вызовов  <b>progn</b>.

<h4>Функция prog1</h4>

Функция <b>prog1</b> похожа на <b>progn</b>, но возвращает в качестве
результата значение своей <i>первой</i> формы-аргумента.
Все формы выполняются последовательно, при этом значение первой
формы сохраняется, и затем возвращается как результат.
<p>
Как правило, <b>prog1</b> используется для оценки значений
выражений с побочными эффектами, в которых интерес представляет
результат, полученный {\it до того}, как эти побочные эффекты вступят в
силу.
Например:
<!--mstheme--></font><pre>
<font color="#000000">(prog1 (car x) (rplaca x 'foo))
</font></pre><!--mstheme--><font face="Times New Roman">
изменяет <i>car</i>-часть ячейки x, делая ее равной  foo
и возвращает прежнее значение <i>car</i>-части x.
<p>
Функция <b>prog1</b> всегда возвращает только одно значение, даже
если сама первая форма, являющаяся ее аргументом, формирует сразу
несколько. В результате
<!--mstheme--></font><pre><font color="#000000">(prog1  x)</font></pre><!--mstheme--><font face="Times New Roman"> и <!--mstheme--></font><pre><font color="#000000">(progn  x)</font></pre><!--mstheme--><font face="Times New Roman"> могут вести себя
по-разному, если <i>x</i> приводит к получению нескольких
значений. 
<p>

<quote><font size=-1>
 Хотя <b>prog1</b> может принудительно возвращать одно единственное
значение, обычно в Common Lisp для этой цели используется
функция  <b>values</b>.
</font></quote>


<h4>Функция prog2</h4>

Функция <b>prog2</b> также похожа на <b>prog1</b>, но возвращает
значение своей <i>второй</i> формы. Все аргументы оцениваются
последовательно, один за другим, при этом результат
вычисления второй формы запоминается и возвращается как результат
всей функции.
В современных программах <b>prog2</b> используется редко, но тем не
менее входит в состав стандартных библиотек функций для
обеспечения совместимости со старым программным обеспечением.
Как видно из приведенного ниже фрагмента, сама по себе эта
функция просто является избыточной.

<!--mstheme--></font><pre>
<font color="#000000">(prog2  a b c ...  z)  =  (progn  a (prog1 b  c ...  z))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Однако в тех случаях, когда необходимо вначале добиться
некоторого побочного эффекта, затем выполнить операцию, формирующую нужное
нам значение, а затем получить еще несколько побочных эффектов,
применение  <b>prog2</b> может оказаться весьма и весьма кстати.
Например:
<!--mstheme--></font><pre>
<font color="#000000">(prog2 (open-a-file) (process-the-file) (close-the-file)) 
   ;значение функции --- process-the-file
</font></pre><!--mstheme--><font face="Times New Roman">

Функция <b>prog2</b>, как и <b>prog1</b>, всегда возвращает одно
значение, даже в том случае, если вторая форма пытается вернуть
сразу несколько. В результате 
<!--mstheme--></font><pre><font color="#000000">(prog2  x  y)</font></pre><!--mstheme--><font face="Times New Roman"> и <!--mstheme--></font><pre><font color="#000000">(progn  x  y)</font></pre><!--mstheme--><font face="Times New Roman"> могут
вести себя по-разному, если  y возвращает несколько значений.

<h2>Установление новых связей переменных</h2>

При вызове функции, которая представляет собой
лямбда-выражение (Или замыкание лямбда-выражения, в
результате выполнения функции <code> function</code>), производится
установление новых связей переменных, которые являются
параметрами этого лямбда-выражения. 
<p>
Кроме того, определенную пользу могут принести описываемые ниже
формы и функции, позволяющие назначить как обычные так и
функциональные связи.
</p>

<h4>Специальная форма  let</h4>
<!--mstheme--></font><pre>
<font color="#000000">let (var | (var [value])*) declaration* form*  
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Форма <b>let</b> предназначена для последовательного выполнения
нескольких форм, в которых осуществляется связывание заданных
переменных с вычисляемыми значениями.
<p>
С формальной точки зрения, форма вида
<!--mstheme--></font><pre>
<font color="#000000">(let ((var1 value1) 
      (var2 value2) 
      ... 
      (varm valuem)) 
  declaration1 
  declaration2 
  ... 
  declarationp 
  body1 
  body2 
  ... 
  bodyn)
</font></pre><!--mstheme--><font face="Times New Roman">
вначале оценивает значения выражений value1,  value2,
и т.д., и сохраняет полученные результаты. Затем все переменные 
 varj одновременно связываются с соответствующими
результатами вычислений; при этом каждое связывание представляет
собой <i>лексическую связь</i>, если только иное не оговаривается
явно с помощью объявления special.
<p>
Затем последовательно вычисляются значения
bodyk; при этом
игнорируются все полученные значения, кроме
последнего (Это означает, что тело <code> let</code> представляет
собой неявную конструкцию <code> progn</code>.). Форма let
возвращает результат оценки значения  bodyn (если тело
пусто, что с практической точки зрения просто не имеет смысла, то
let возвращает в качестве значения NIL).
<p>
Допускается вместо списка ( varj valuej),
использовать просто запись varj. В этом случае varj
вначале присваивается значение равное NIL. В соответствии с
правилами хорошего тона рекомендуется использовать varj
только в тех случаях, когда значение этой переменной до своего первого
использования будет сохранено, например, с помощью
setq.
И если для правильной работы алгоритма необходимо, чтобы
начальное значение было именно NIL, то рекомендуется
откровенно указывать --- (varj NIL), если
начальное значение должно означать ``false,''или
(varj '()), если начальное значение должно
представлять собой пустой список.
<p>
Например, фрагмент кода

<!--mstheme--></font><pre>
<font color="#000000">(let (x) 
  (declare (integer x)) 
  (setq x (gcd y z)) 
  ...)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
содержит ошибку --- несмотря на то, что x в самом деле
получает значение до того, как будет использовано, при этом оно
должно иметь тип integer, а поскольку при инициализации
x моментально получает значение NIL, это приводит к
к тому, что фиксируется нарушение типа переменной --- ведь NIL
не является целым числом...
<p>
Объявления типов переменных могут располагаться только в
начале тела формы let.
<p>

<h4>Специальная форма let*</h4>
<!--mstheme--></font><pre>
<font color="#000000">let* (var | (var [value])*) declaration* ,form
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Специальная форма let* в целом подобна let, и
отличается лишь тем, что связывание переменных осуществляется не
одновременно, а последовательно. Это позволяет в выражениях
ссылаться на значения переменных, которые уже были вычислены ранее в
этой же форме let*.
<p>
Иначе говоря, форма 
<!--mstheme--></font><pre>
<font color="#000000">(let* ((var1 value1) 
       (var2 value2) 
       ... 
       (varm valuem)) 
  declaration1 
  declaration2 
  ... 
  declarationp 
  body1 
  body2 
  ... 
  bodyn)
</font></pre><!--mstheme--><font face="Times New Roman">
вначале оценивает значение  value1, затем связывает с этим
значением переменную  var1; после этого оценивается значение
 value2 и результат связывается с  var2, затем процесс
продолжается...
<p>
После этого осуществляется последовательное вычисление выражений
bodyj. Все полученные значения кроме последнего
(bodyn)
отбрасываются (Это означает, что тело <code> let</code> представляет
собой неявную конструкцию <code> progn</code>.).  
Форма let* возвращает результат оценки
 bodyn (если ни одной формы не вызывалось, let* возвращает
NIL).
<p>
Допускается вместо списка ( varj valuej),
использовать просто запись varj. В этом случае  varj
вначале присваивается значение равное NIL. В соответствии с
правилами хорошего тона рекомендуется использовать  varj
только в тех случаях, когда значение этой переменной до своего первого
использования будет сохранено, например, с помощью
setq.
И если для правильной работы алгоритма необходимо, чтобы
начальное значение было именно NIL, то рекомендуется
откровенно указывать --- ( varj NIL), если
начальное значение должно означать ``false,''или
( varj '()), если начальное значение должно
представлять собой пустой список.
<p>
Вначале области тела let* могут помещаться объявления типа
переменных. 

<h4>Специальная форма   compiler-let</h4>
<!--mstheme--></font><pre>
compiler-let (var | (var [value])*) ,form*
</pre><!--mstheme--><font face="Times New Roman">
<p>
В тех случаях, когда compiler-let выполняется интерпретатором
Лиспа, эта функция ведет себя аналогично let, включая
неявные объявления special для связей переменных. Однако
если эта форма обрабатывается компилятором, то код для вычисления
значений переменных не генерируется. Вместо этого, обработка тела
компилятором (включая все расширения макросов в теле) выполняются
с использованием специальных переменных, ассоциируемых с
используемыми в форме значениями, назначенным введенным
переменным. Основное назначение этой формы состоит в упрощении
организации взаимодействия между сложными макросами.
<p>
В теле этой формы не допускается использование объявлений типа.
</p>
Во многих современных реализациях CommonLisp эта форма
отсутстствует. Вместо нее рекомендуется использовать
macrolet или symbol-macrolet.

<h4>Специальная форма progv</h4>
<!--mstheme--></font><pre>
<font color="#000000">progv symbols values ,form*
</font></pre><!--mstheme--><font face="Times New Roman">
Форма progv позволяет выполнять связывание одной или
нескольких переменных, имена которых определяются во время
выполнения программы. При этом оцениваются значения
последовательности форм (неявный <b>progn</b>) которые
присваиваются динамическим переменным, имена которых находятся в
списке символов  symbolsв соответствии со списком
values.
<p>
<quote><font size=-1>
 Если форма содержит слишком мало значений, то все оставшиеся
символы не получают никакого значения; см.
makunbound. Если
передано слишком много значений, то все лишние игнорируются.
</font></quote>
<p>
Результатом вызова progv является значение, полученное при
оценке последней формы form. Все связи динамических
переменных действуют только в пределах формы
progv.
<p>
Форма progv особенно полезна при написании интерпретаторов
на Лиспе и предоставляет программисту удобный механизм для
связывания динамических переменных.

<h4>Специальная форма flet</h4>

<!--mstheme--></font><pre>
<font color="#000000">flet ((name lambda-list
        <declar* | doc> ,form*)*)
     ,form* 
labels ((name lambda-list
          <declar* | doc> ,form*)*)
       ,form* 
macrolet ((name varlist
            <declar* | doc> ,form*)*)
         ,form*
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Специальная форма flet может использоваться для определения
локальных функций. Внутри тела формы flet, имена функций,
которые совпадают с теми, которые были определены внутри формы
относятся только к локальным определениям, а не к глобальным
функциям с такими же именами.
<p>
Можно определить произвольное количество функций. При этом каждое
определение по формату подобно форме defun form: вначале
задается имя, затем список параметров (который может содержать
ключи &amp;optional, &amp;rest, или &amp;key), затем
следуют необязательные объявления типов и строки
документирования, и наконец, собственно тело функции.
<p>
Например:

<!--mstheme--></font><pre>
<font color="#000000">(flet ((safesqrt (x) (sqrt (abs x)))) *
  ;; Функция safesqrt используется дважды. *
  (safesqrt (apply #'+ (map 'list #'safesqrt longlist))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Конструкция labels в основном идентична рассмотренной выше
flet. Однако эти конструкции различны с той точки зрения,
что имена функций flet влияют только не тело функции, в то
время как labels относится к самим определениям этих
функций. Это означает, что labels могут использоваться для
определения взаимно рекурсивных функций, что невозможно сделать с
помощью flet. Именно это различие делает форму labels
настолько полезной. Использование flet позволяет локально
переопределить имя функции, но новое локальное определение будет ссылаться
на глобальное определение; а вот при использовании labels
такого эффекта не возникнет. Вот небольшой пример:
<!--mstheme--></font><pre>
<font color="#000000">(defun integer-power (n k)       ; Функция возведения в степень *
  (declare (integer n))          ; целого числа *
  (declare (type (integer 0 *) k)) 
  (labels ((expt0 (x k a) *
             (declare (integer x a) (type (integer 0 *) k)) *
             (cond ((zerop k) a) *
                   ((evenp k) (expt1 (* x x) (floor k 2) a)) *
                   (t (expt0 (* x x) (floor k 2) (* x a))))) 
           (expt1 (x k a) *
             (declare (integer x a) (type (integer 1 *) k)) *
             (cond ((evenp k) (expt1 (* x x) (floor k 2) a)) *
                   (t (expt0 (* x x) (floor k 2) (* x a)))))) *
    (expt0 n k 1)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Наконец, форма macrolet также подобна flet, но
предназначена для определения локальных макросов, используя точно
такой же формат, что и defunro.
<p>
Довольно часто макросы должны расширяться на этапе компиляции, то
есть до начала собственно выполнения программы, и это означает,
что значения переменных получаемые во время исполнения становятся не
доступны макросам, определенным с помощью
macrolet.
Объекты с лексической областью видимости, тем не менее, доступны
внутри тела формы macrolet и, естественно, доступны коду,
который генерируется в результате расширения макроса. Например:
<!--mstheme--></font><pre>
<font color="#000000">;;; Пример использования macrolet. *
*
(defun foo (x flag) *
  (macrolet ((fudge (z) *
                ;; Параметры x и flag в этот момент  *
                ;; недоступны; ссылка на flag относится *
                ;;  к глобальной переменной с таким именем. *
                `(if flag 
                     (* ,z ,z) 
                     ,z))) 
    ;; А здесь параметры x и flag доступны. *
    (+ x *
       (fudge x) *
       (fudge (+ x 1)))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
После расширения макроса, определенного с помощью
macrolet,
мы получим:
<!--mstheme--></font><pre>
<font color="#000000">(+ x *
   (if flag *
       (* x x) *
       x)) *
   (if flag *
       (* (+ x 1) (+ x 1)) *
       (+ x 1)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Все упоминания x и flag вполне корректно относятся к
параметрам функции foo, поскольку эти параметры видимы
макровызову во время его расширения.


<h4>Специальная форма symbol-macrolet</h4>
<!--mstheme--></font><pre>
<font color="#000000">symbol-macrolet ((var expansion)*)
                declaration* ,form*
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Появление формы symbol-macrolet отражает интеграцию в
CommonLisp объектно-ориентированного расширения
CLOS, которое
мы рассмотрим отдельно, и уж точно не в этом году. Однако
symbol-macrolet может использоваться и независимо от
CLOS.
<p>
Формы  forms выполняются как неявный вызов <b>progn</b> в
лексическом окружении, которое приводит к тому, что каждая ссылка
на любую переменную var, определенную при вызове
symbol-macrolet, заменяется соответствующим ей выражением
expansion. Можно считать, что ссылка на переменную  var
интерпретируется как макровызов без параметров; затем либо оценивается
значение  expansion либо помещается на место ссылки.
<p>
Обратите внимание, что имена, создаваемые таким образом,
используют пространство имен переменных, но не функций; поэтому
вы можете иметь функцию (или макрос, или специальную форму) и
одновременно --- переменную с тем же самым именем, и это не
приведет ни к каким конфликтам.
<p>
Однако это приводит к тому, что результат symbol-macrolet может быть
затенен при последующем использовании let или других
конструкций, которые осуществляют связывание переменных;
symbol-macrolet не выполняет подстановку всех обращений к
 var вообще, а только тех, которые конструируются как ссылки
к переменным в области действия лексической связи  var как
переменной. Например:
<!--mstheme--></font><pre><font color="#000000">
(symbol-macrolet ((pollyanna 'goody)) 
  (list pollyanna (let ((pollyanna 'two-shoes)) pollyanna))) 
;; (goody two-shoes ) -- но не (goody goody)!
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Вам может показаться, что 'goody просто заменяет все
обращения к символу pollyanna, и значением let будет
goody; но не все так просто! В случае такого поведения
системы мы получили бы:
<!--mstheme--></font><pre><font color="#000000">
(list 'goody (let (('goody 'two-shoes)) 'goody))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
что синтаксически неверно. Правильная расширенная форма
представляет собой:
<!--mstheme--></font><pre><font color="#000000">
(list 'goody (let ((pollyanna 'two-shoes)) pollyanna))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
поскольку смена связи pollyanna формой let затеняет
символ из макроопределения.<p>
Расширение expansion, ассоциируемое с каждой переменной  var
оценивается не во время связывания, но только после того, как
будет заменено обращение к var. Макрос
setf позволяет использовать этот макрос как место применения
нового значения, в качестве которого используется расширение
этого макроса; кроме того setq для переменной, которая на
самом деле является макро-символом, также интерпретируется как
применение setf. Форма возвращает значение последней формы,
либо nil, если не было получено никакого значения.
<p>
Имейте в виду, что использование объявлений типов 
declarations перед телом хотя и допускается, но может приводить
к неожиданным результатам.

<h2>Кондиционалы</h2>

Кондиционалом в Лиспе по традиции называется группа функций,
выполнение которых осуществляется в зависимости от выполнения тех
или иных условий. Их можно было бы назвать и операторами
условного выполнения, однако, как вы увидите ниже, реальная сфера
применения кондиционалов гораздо шире.
<p>
Традиционной для Лисп конструкцией, предназначенной для
организации условного выполнения функций является, конечно же
cond. Однако более удобной и простой является форма
if, которая навевает прямые ассоциации с условными
операторами в других языках программирования. Поэтому, в целях
соблюдения преемственности с Бейсиком и Паскалем мы начнем
обсуждение условных операторов именно с этой формы. Кроме того,
мы рассмотрим конструкции case и typecase, которые
также покажутся начинающим более удобными чем
cond.

<h4>Специальная форма if</h4>
<!--mstheme--></font><pre>
<font color="#000000">if test then [else]
</font></pre><!--mstheme--><font face="Times New Roman"><p>
Специальная форма if соответствует конструкции  if-then-else,
реализованной в большинстве современных языков программирования
процедурного типа. Вначале осуществляется оценка значения формы 
 test. Если полученный результат отличен от NIL,
выполняется форма  then; в противном случае выполняется форма
 else. Сама форма if возвращает в качестве результата
значение выполненной формы.
<p>
С точки зрения традиционного Лиспа конструкция if
эквивалентна:
<!--mstheme--></font><pre>
<font color="#000000">(if  test  then  else) &lt;=&gt; (cond ( test  then) ({\true  else))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
но понятно, что if в некоторых случаях более удобна.
<p>
Форма  else может отсутствовать, в этом случае если значение 
 test равно NIL, то никаких дополнительных действий не
выполняется и значение всей формы if становится равным NIL.
Если значение, возвращаемое формой ifв этой ситуации имеет
для вас значение, то более предпочтительным может быть
использование and. Если же возвращаемое значение роли не
играет, то более удобным может оказаться when.

<h4>Форма  when</h4>
<!--mstheme--></font><pre>
<font color="#000000">when test form*
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Форма вида (when  test  form1  form2 ... )
вначале оценивает значение условия  test. Если результат
равен NIL, то  form не выполняется и возвращается NIL.
В противном случае формы  form образуют неявный <b>progn</b> и
оцениваются последовательно, слева направо. Значение последней
формы становится значением всей функции.
<!--mstheme--></font><pre><font color="#000000">
(when  p  a  b  c)   ;;  (and  p (progn  a  b  c)) 
(when  p  a  b  c)   ;; (cond ( p  a  b  c)) 
(when  p  a  b  c)   ;; (if  p (progn  a  b  c) NIL) 
(when  p  a  b  c)   ;; (unless (not  p)  a  b  c)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Обычно when используется для условного формирования тех или
иных побочных эффектов, а значение, которое возвращает
when, в большинстве случаев не используется. Если же
возвращаемое значение представляет для вас практический интерес,
то более предпочтительно использовать and или if.

<h4>Форма unless</h4>
<!--mstheme--></font><pre>
<font color="#000000">unless test ,form*
</font></pre><!--mstheme--><font face="Times New Roman">

Форма (unless  test  form1  form2 ... )
вначале вычисляет значение  test. Если результат 
отличен от NIL,
то формы  form не оцениваются, и возвращается NIL. В
противном случае формы  form образуют неявный вызов 
<b>progn</b> и оцениваются слева направо. Значение последней формы
возвращается как значение всей функции.
<!--mstheme--></font><pre>
<font color="#000000">(unless  p  a  b  c) ;; (cond ((not  p)  a  b  c)) 
(unless  p  a  b  c) ;; (if  p NIL (progn  a  b  c)) 
(unless  p  a  b  c) ;; (when (not  p)  a  b  c)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
В большинстве случаев эта форма используется ради ее побочных
эффектов, и возвращаемое ею значение не используется. Если же
результат вычислений имеет практическое значение, то имеет смысл
вместо unless использовать  if.

<h4>Форма  cond</h4>
<p>
<br>
<font color="#000000">cond (test form*)*<br>
</font>
</pre<p>

<br>
<br>
Форма cond может иметь произвольное
количество (включая нуль)<br>
вариантов, которые представляют собой
список форм. Каждый из<br>
вариантов состоит из условия&nbsp; test, за
которым следует нуль<br>
или больше следствий&nbsp; consequents.<br>
<p>
Например:
<!--mstheme--></font><pre><font color="#000000">
(cond ( test-1  consequent-1-1  consequent-1-2 ...) 
      ( test-2) 
      ( test-3  consequent-3-1 ...) 
      ... )
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Выполняется первый вариант, в котором  test получает
значение, отличное от NIL; все остальные варианты
игнорируются, а следствия в выбранном варианте выполняются
последовательно, образуя неявный вызов <b>progn</b>.
<p>
С формальной точки зрения cond последовательно просматривает
варианты слева направо. Для каждого варианта производится оценка
условия   test.  Если результатом является 
NIL, cond переходит к анализу следующего варианта.
В противном случае  cdr-часть варианта рассматривается как
список форм, подлежащих последовательному исполнению, и они
оцениваются слева направо, как неявный  <b>progn</b>.
После завершения выполнения cond завершает работу, даже не
приступая к анализу следующих вариантов.
<p>
Если для выбранного cond варианта отсутствовал список
следствий, то возвращается результат оценки теста. И наконец,
если в ходе проверки не удалось найти ни одного подходящего
варианта, то значением cond становится NIL.
<p>
В тех случаях, когда необходимо, чтобы последний вариант
выполнялся в любом случае (то есть тогда, когда все остальные
проверки, расположенные ранее, окончились фиаско), то обычно в
качестве теста используется  T.

<quote><font size=-1>
&nbsp;
</font>
<blockquote>
<p>
<font size=-1>
Согласно правилам хорошего счета рекомендуется всегда помещать в
конце формы cond вариант (T NIL).
</font></quote>
</blockquote>
<p>
Например:
<!--mstheme--></font><pre>
<font color="#000000">(setq z (cond (a 'foo) (b 'bar)))              ; Возможно, непонятно... 
(setq z (cond (a 'foo) (b 'bar) (T NIL)))      ; Это лучше 
(cond (a b) (c d) (e))                         ; И это непонятно 
(cond (a b) (c d) ({\true e))                  ; А это лучше 
(cond (a b) (c d) ({\true (values e)))         ; Еще лучше, если нужно  
 				               ; только одно значение 
(cond (a b) (c))                               ; Это тоже непонятно 
(cond (a b) (t c))                             ; И лучше вот так 
(if a b c)                                     ; А еще лучше так
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Форму cond в Лиспе можно сравнить с традиционной расширяемой  конструкцией
if- then- else, используемой в большинстве языков
программирования:
<p>
<!--mstheme--></font><pre>
<font color="#000000">(cond ( p ...)                                if  p  then ... 
      ( q ...)                     грубо           else  if  q  then ... 
      ( r ...)                соответствует        else  if  r  then ... 
      ...                                                ... 
      (T ...))                                     else ...
</font></pre><!--mstheme--><font face="Times New Roman">

<h4>Форма case</h4>
<!--mstheme--></font><pre>
<font color="#000000">case keyform ((key*) | key ,form*)*
</font></pre><!--mstheme--><font face="Times New Roman"><p>
Форма case представляет собой кондиционал, который выбирает
для выполнения один из вариантов путем сравнения значения формы
keyform с различными константами key, которые обычно
представляют собой ключевые слова, числа или символы, но можно,
вообще говоря, использовать произвольные объекты Лиспа. Формат
этой формы следующий:<!--mstheme--></font><pre>
<font color="#000000">(case  keyform 
  ( keylist-1  consequent-1-1  consequent-1-2 ...) 
  ( keylist-2  consequent-2-1 ...) 
  ( keylist-3  consequent-3-1 ...) 
  ...)
</font></pre><!--mstheme--><font face="Times New Roman"><p>
По своей структуре case во многом похож на cond, да и
ведет себя похоже. Однако case отличается в части работы
механизма выбора исполняемого варианта.
<p>
Первое, что делает case - это оценка значения формы 
keyform, для получения объекта, который называется
 ключевым объектом формы. Затем case по очереди
рассматривает все варианты. Если при этом ключ  key
находится в  keylist, то есть равен в смысле  eql
какому либо объекту в  keylist данного варианта, то
следствия этого варианта оцениваются как неявный
<b>progn</b>;  case возвращает то, что было возвращено
последним следствием либо NIL, если в данном варианте не
было ни одного следствия. Если не удается найти ни одного
подходящего варианта, то case возвращает NIL.
<p>
Ключи в списках при этом не оцениваются; поэтому в них могут
использоваться только литеральные ключи. Не допускается
использовать один и тот же ключ в нескольких вариантах, в
противном случае поведение всей формы case не будет
соответствовать ожидаемому.
<p>
Допускается вместо списка ключей  keylist, использовать один
из символов --- T или otherwise. Вариант, содержащий
такой символ, всегда будет выполняться, а поэтому должен быть
размещен в самом конце формы (Это единственное исключение
из правила, которое гарантирует независимость порядка следования
операторов).
<p>
В том случае, когда варианту соответствует один единственный
ключ, он может записываться вместо списка, состоящего из одного
элемента. При этом никакой неоднозначности в интерпретации ключей
не возникает. Такой ключ не может иметь значение NIL (которое
может быть интерпретировано как () - список без ключей),
T, или представлять собой cons-ячейку.

<h4>Форма typecase</h4>
<!--mstheme--></font><pre>
<font color="#000000">typecase keyform (type {,form*)*
</font></pre><!--mstheme--><font face="Times New Roman"><p>
Форма typecase представляет собой кондиционал, который
выбирает один из вариантов в соответствии с типом переданного ему
объекта. Форма может быть интерпретирована следующим образом:
<!--mstheme--></font><pre>
<font color="#000000">(typecase  keyform *
  ( type-1  consequent-1-1  consequent-1-2 ...) *
  ( type-2  consequent-2-1 ...) *
  ( type-3  consequent-3-1 ...) 
  ...)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
По своей структуре typecase во многом схожа с cond или case,
и ведет себя почти так же, выбирая и выполняя один из вариантов.
Однако, эта форма отличается от упомянутых выше механизмом выбора
варианта.
<p>
Прежде всего это отличие typecase, состоит в оценке значения
формы  keyform, которая должна сгенерировать объект, который
называется ключевым объектом. Затем typecase последовательно
рассматривает каждый из вариантов. При проверке варианта
осуществляется сопоставление полученного типа ключевого объекта
со спецификатором типа  type, который не оценивается при
вызове функции и должен представлять собой литеральный
спецификатор типа. Выполняется первый  вариант, спецификатор типа которого
удовлетворяет типу ключевого объекта. Следствия этого варианта
выполняются как неявный вызов <b>progn</b>,
и typecase возвращает результат оценки последней формы.
Если в данном варианте не было описано ни одной формы, либо если
не удалось подобрать ни одного варианта, то typecase
возвращает NIL.
<p>
Допускается использовать один и тот же спецификатор типа в
различных вариантах, например, в тех случаях, когда один из них
является подтипом другого; в этом случае выполняется тот, который
будет проанализирован раньше. Таким образом, при работе с typecase, в
отличие от case, порядок следования вариантов оказывает
влияние на поведение всей формы в целом.
Например:
<!--mstheme--></font><pre>
<font color="#000000">(typecase an-object 
   (string ...)              ; Этот вариант обрабатывает строки 
   ((array t) ...)           ; Этот --- массивы общего вида 
   ((array bit) ...)         ; Этот --- битовые массивы 
   (array ...)               ; А этот --- все прочие массивы 
   ((or list number) ...)    ; Обработка списков и чисел 
   (t ...))                  ; И наконец, всех прочих объектов
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
В некоторых реализациях Common Lisp, компилятор может
сгенерировать предупреждение, если вариант никогда не может быть
выполнен из за его затенения более ранними вариантами.


      <p> &nbsp; </p>
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>



      <p> &nbsp; </p>
&nbsp;
<!-- SpyLOG f:0211 -->
<script language="javascript"><!--
Mu="u4689.42.spylog.com";Md=document;Mnv=navigator;Mp=1;
Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();
Mt=(new Date()).getTimezoneOffset();
Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;
My="";
My+="<a href='http://"+Mu+"/cnt?cid=468942&f=3&p="+Mp+"&rn="+Mrn+"' target='_blank'>";
My+="<img src='http://"+Mu+"/cnt?cid=468942&"+Mz+"&r="+escape(Md.referrer)+"&pg="+escape(window.location.href)+"' border=0  width=88 height=31  alt='SpyLOG'>";
My+="</a>";Md.write(My);//--></script><noscript>
<a href="http://u4689.42.spylog.com/cnt?cid=468942&f=3&p=1" target="_blank">
<img src="http://u4689.42.spylog.com/cnt?cid=468942&p=1" alt='SpyLOG' border='0'  width=88 height=31 >
</a></noscript>
<!-- SpyLOG  --><!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p>
<script type="text/javascript"><!--
var yandex_r = Math.round(Math.random() * 100000);
document.write('<sc'+'ript type="text/javascript" src="http://an.yandex.ru/code/14812?rnd=' + yandex_r + '&direct-style=2&direct-limit=4&market-style=0&market-limit=4"></'+'sc'+'ript>');
//--></script>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h5>Послать письмо <a href="mailto:voldemarus@narod.ru">
voldemarus@narod.ru</a> &nbsp;<br>
Авторские права © 2003-2009
Картонная армия<br>
Последнее изменение:
января 09, 2010</h5>
<p></p>
<p></p>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>


