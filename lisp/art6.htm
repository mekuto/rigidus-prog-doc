
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">


<title>GNU Common Lisp - часть 6, структуры данных</title>
<meta name="Microsoft Theme" content="blueprnt 0000, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body bgcolor="#FFFFFF" text="#003399" link="#3366FF" vlink="#9900FF" alink="#000066"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p></p>
<p>&nbsp;<img src="../../images/cartonarmy.gif" alt="[Картонная Армия - от галеры до ракеты!]" border="0" width="468" height="60">
</p>
<p>
<a href="../../index.htm"><img src="../../_derived/home_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Домой" align="middle"></a> <a href="../gcl.htm"><img src="../../_derived/up_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Вверх" align="middle"></a> <a href="../../toc.htm"><img src="../../_derived/toc.htm_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Содержание" align="middle"></a></p>
<p>
<img src="_derived/art6.htm_cmp_blueprnt000_bnr.gif" width="600" height="60" border="0" alt="Структуры данных">
<br>
<a href="art1.htm"><img src="_derived/art1.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - первые шаги" align="middle"></a> <a href="art2.htm"><img src="_derived/art2.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp -атомы и списки" align="middle"></a> <a href="art3.htm"><img src="_derived/art3.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - переменные" align="middle"></a> <a href="art4.htm"><img src="_derived/art4.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - вызов функций" align="middle"></a> <a href="art5.htm"><img src="_derived/art5.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Программные блоки" align="middle"></a> <img src="_derived/art6.htm_cmp_blueprnt000_hbtn_p.gif" width="140" height="60" border="0" alt="Структуры данных" align="middle">
</p>
<p>&nbsp;</p>

<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Times New Roman">
<p>&nbsp;</p>
<p><a href="http://">
</a>
</p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Times New Roman">
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>
<h4 align="right">В.Водолазкий</h4>
<H1><!--mstheme--><b>Первые шаги в Common Lisp - Структуры данных<!--mstheme--></b></H1>
<P>
<center>Часть 6</center>
<P>&nbsp;<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p><P>
&nbsp;
<P>
В Common Lisp реализован удобный механизм создания записей,
содержащих именованные компоненты. Это позволяет определить
пользователю новые типы данных; каждый символ такого типа будет
содержать все компоненты, определенные при задании типа. При
определении структур автоматически создаются конструктор всей
структуры, функции доступа к отдельным компонентам как на чтение,
так и на запись, а также предикат, проверяющий принадлежность
символа к структуре данного типа. 
<P>
&nbsp;
<h2>Введение в структуры</h2>
<P>
Механизм структур в Common Lisp почти полностью скрывается в
одном единственном макросе -- <code>defstruct</code>, который
позволяет пользователю создавать и использовать агреггированные
типы данных с именованными полями (элементами). По большому
счету, этот макрос явился ответом на "структуры", используемые
в старом добром PL/I, или &quot;records&quot; в языке Паскаль.
<P>
Начнем с примера. Предположим, что вы разрабатываете очередную
версию Стар-трека -- одну из первых компьютерных игр, но на этот
раз на Лиспе. Одна из задач, которая стоит перед вами, состоит в
управлении космическими кораблями, которые перемещаются в
двумерном координатном пространстве. Понятно, что корабль должен
представляться Лисп-объектом некоторого типа. В нашей игре 
каждый корабль будет характеризоваться текущими координатами
(в виде пары <i>x</i> и <i>y</i>), скоростью 
(представляемой в виде проекций вдоль осей <i>x</i> и <i>y</i>
 axes), и массой корабля.
<P>
В результате корабль может быть представлен как запись, имеющая
пять составляющих: <i>x</i>-координата, <i>y</i>-координата,
<i>x</i>-скорость, <i>y</i>-скорость, и масса. Эта структура, в
свою очередь, может быть реализована в Лиспе несколькими
способами.
<P>
Во-первых, это может быть список, состоящий из пяти
элементов -- в этом случае <i>x</i>-координата извлекается с
помощбю функции <b>car</b>, <i>y</i>-координата -- с помощью <b>cadr</b>,
и так далее. Аналогичным образом можно попытаться использовать
пятиэлементный вектор: <i>x</i>-координата будет
храниться в
элементе с номером 0, координата 
<i>y</i> -- в элементе с номером 1, и так далее. Однако при
использовании любого из этих представлений возникает общая
проблема, состоящая в том, что компоненты занимают внутри объекта
позиции, выбираемые достаточно произвольным образом, что довольно
сложно запомнить, и что, в конце концов, приводит к различным
ошибкам.
<P>
Например, если взглянуть на запись <code>(cadddr ship1)</code> или
<code>(aref ship1 3)</code>, то догадаться, что речь идет об 
<i>y</i>-составляющей вектора скорости  <code>ship1</code> весьма нелегко.
Более того, если в силу каких-либо обстоятельств представление
данных о корабле будет изменено, то найти все участки кода
программы, которые должны быть изменены будет еще сложнее
(например, речь идет не обо всех вызовах функции <code>cadddr</code>, а лишь о
тех, котрые предназначены для извлечения <i>y</i>-составляющей
скорости корабля).


<P>
В идеальном случае компоненты таких структур должны иметь имена.
Например, достаточно удобно использовать конструкцию:
<code>(ship-y-velocity ship1)</code> вместо неудобоваримой 
<code>(cadddr ship1)</code>.
Можно также попытаться использовать более удобный способ создания
записи о параметрах корабля по сравнению с:
<!--mstheme--></font><pre>
<font color="#000000">(list 0 0 0 0 0)</font>
</pre><!--mstheme--><font face="Times New Roman">
<P>
В самом деле, разве не удобнее определить <code>ship</code> как новый
тип данных, аналогичный другим типам данных в Лиспе, который мог
бы, например, проверяться с помощью предиката  <code>typep</code>.
Для этого в Common Lisp предусмотрен всего лишь один механизм ---
<code>defstruct</code>, которого, впрочем, вполне достаточно.

<P>
Сам по себе вызов <code>defstruct</code> представляет собой маакрос,
который создает описание структуры. Например, для описания
параметров космического корабля, мы можем определить следующую
структру:
<!--mstheme--></font><pre>
<font color="#000000">(defstruct ship 
  x-position 
  y-position 
  x-velocity 
  y-velocity 
  mass)
</font></pre><!--mstheme--><font face="Times New Roman">


<P>
В результате мы сможем создавать произвольное количество
кораблей, как объекты типа <code>ship</code>, имеющие по пять
именованных компонентов. Оценка значений компонентов и объекта
целиком может выполняться с помощью различных средств, которые
автоматически генерируются при определении структуры:
<!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">
<code>ship-x-position</code> интерпретируется как функция с одним
аргументом -- именем корабля, которая возвращает 
<i>x</i>-координату корабля; <code>ship-y-position</code> и другие
компоненты представляют собой определения аналогичных функций.
Эти функции называются <b>функциями доступа</b>, поскольку они
используются для доступа к отдельным элементам структуры.
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Символ <code>ship</code> становится именем (названием) типа данных,
экземпляры которого содержат определенные с помощью
<code>defstruct</code> компоненты. Это имя становится распознеаваемым
с помощью предиката  <code>typep</code>;
в результате <code>(typep x 'ship)</code> принимает значение
  T,
если  <code>x</code> является кораблем и NIL, если
<code>x</code> представляет собой объект любого другого типа.
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Определяется предикат <code>ship-p</code>, использующий один аргумент,
который принимает значение T, если аргумент имеет тип 
<code>ship</code>, и NIL, если он имеет любой другой тип.
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Создается функция <code>make-ship</code>, которая при вызове создает
новую структуру данных с пятью компонентами, которая пригодна для
использования совместно с функциями доступа. В результате
выполнение
<!--mstheme--></font><pre>
<font color="#000000">(setq ship2 (make-ship))
</font></pre><!--mstheme--><font face="Times New Roman">
устанавливает <code>ship2</code> равным вновь созданному объекту типа
<code>ship</code>. При необходимости можно задать начальные значения
для любого из компонентов путем вызова <code>make-ship</code> с
ключевыми аргументами следующим образом:
<!--mstheme--></font><pre>
<font color="#000000">(setq ship2 (make-ship :mass *default-ship-mass* 
                       :x-position 0 
                       :y-position 0))
</font></pre><!--mstheme--><font face="Times New Roman">
В результате будет создан новый корабль и одновременно будет
установлено значение трех его параметров. Эта функция называется
обычно <b>конструктором</b>, поскольку собирает (конструирует)
новую структуру.
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Для чтения значений экземпляров <code>ship</code> может
использоваться синтаксис <code>#S</code>, а кроме того, в Common
Lisp реализована функция печати, позволяющая выводить
произвольные структуры данных. Например, значение переменной
<code>ship2</code>, определенной выше, может быть выведено в
следующем виде:
<!--mstheme--></font><pre>
<font color="#000000">#S(ship  x-position 0  y-position 0  x-velocity nil 
         y-velocity nil  mass 170000.0)
</font></pre><!--mstheme--><font face="Times New Roman">

<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Определяется функция с именем <code>copy-ship</code>, которая
принимает один аргумент, и при передаче ей объекта типа
<code>ship</code>, создаст новый объект типа <code>ship</code>, который
является копией исходного. Эта функция называется
<b>копировщиком</b>.
<p>
<quote><font size=-1>
В просторечьи, ее иногда называют
также <i>ксероксом</i>, что является русифицированной калькой с
англоязычного термина <i> copier function</i>.
</font></quote>
</p>
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman">Для изменения значений компонентов <code>ship</code> можно
использовать функцию <code>setf</code>:
<!--mstheme--></font><pre>
<font color="#000000">(setf (ship-x-position ship2) 100)
</font></pre><!--mstheme--><font face="Times New Roman">
В результате <i>x</i>-координата корабля <i>ship2</i> получит новое
значение, равное <code>100</code>. Этот механизм работает потому, что 
макрос <code>defstruct</code> фактически генерирует соответствующие
каждому компоненту формы <code>defsetf</code>.
<!--msthemelist--></table><!--mstheme--><font face="Times New Roman">
<P>
Этот простой пример наглядно демонстрирует мощь и красоту макроса
<code>defstruct</code> в части упрощения практической реализации
абстрактных структур данных. Стоит также отметить, что
<code>defstruct</code> имеет еще несколько полезных функций,
предназначенных для использования в некторых специфических
ситуациях.

<h2>Как использовать defstruct с максимальной пользой</h2>

Абсолютно все структуры в Common Lisp определяются с помощью
конструкции <code>defstruct</code>. Вызов <code>defstruct</code>
определяет новый тип данных, все экземпляры которого содержат
один итот же набор именованных компонентов.


<P>
&nbsp;
<h3>Макрос defstruct</h3>
<!--mstheme--></font><pre>
<font color="#000000">defstruct name-and-options [doc-string] slot-description*
</font></pre><!--mstheme--><font face="Times New Roman">

<P>
Эта макрокоманда предназначена для определения структур данных в
Common Lisp. Наиболее распространенное использование  <code>defstruct</code>
выглядит так, как это показано в следующем примере.
<!--mstheme--></font><pre>
<font color="#000000">(defstruct ( name  option-1 option-2 ... option-m) 
            doc-string
            slot-description-1
            slot-description-2
            ... 
            slot-description-n)
</font></pre><!--mstheme--><font face="Times New Roman">
Аргумент <i>name</i> должен быть символом; он становится именем
нового типа данных, состоящего из всех экземпляров структуры.
Функция <code>typep</code> после определения структуры сможет
распознавать и корректно обрабатывать это имя.


<P>
Это же имя <i>name</i> возвращается в качестве результата
выполнения формы defstruct.

<P>
Впрочем, в наиболее распространенных случаях никакие
дополнительные параметры не нужны вообще. При этом вы
можете написать просто имя  <i>name</i>, вместо 
<code>( name)</code> после слова <code>defstruct</code>. 
<p>
Если при описании структуры используется необязательная строка
документирования <i>doc-string</i>, она присоединяется к типу
name, как строка документации типа 
<code>structure</code>.

<P>
Каждое из описаний компонентов <i>slot-description-j</i> имеет
следующий вид:
<!--mstheme--></font><pre>
<font color="#000000">( slot-name  default-init
  slot-option-name-1  slot-option-value-1
  slot-option-name-2  slot-option-value-2
  ... 
  slot-option-name-k  slot-option-value-k)
</font></pre><!--mstheme--><font face="Times New Roman">


<P>
При этом каждый <i>slot-name</i> должен представлять собой символ;
именно это позволяет создать для каждого слота (компонента)
соответствующую функцию доступа. Если же при определении
структуры не заданы ни параметры ни объявление
<i>default-init</i>, то вы можете просто написать
<i>slot-name</i> вместо <code>( slot-name)</code> при описании
соответствующего компонента.


<P>
Форма <i>default-init</i> оценивается всякий раз при создании
структуры; полученное значение используется в качестве начального
значения соответствующего компонента.
Эта форма оценивается  только в том случае, если
соответствующие начальные значения не передаются конструктору
структуры явным образом.
Если при определении структуры <i>default-init</i> задана не была,
то начальные значения компонентов, по большому счету не
определены и зависят от реализации системы.<P>
В ряде случаев может оказаться удобным использовать объявление
структур вообще без каких-либо компонентов. Такие определения,
несмотря на кажущуюся абсурдность, оказываются полезными в тех
случаях, когда используется параметр :include, конечно,
совместно с другими параметрами. Например, вы можете иметь две
структуры, которые в целом подобны друг другу, за исключением
того, что по-разному выводятся на печать (потому что имеют
различные реализации функции :print-function).

<P>
Макрос defstruct не только определяет функции доступа
для каждого компонента, но также настраивает
setf для
корректной работы с такими функциями доступа, а также определяет
предикат name-p, функцию конструктора make-name, и функцию копировщика
copy-name. Все имена автоматически созданных
функций становятся домашними для того пакета, который является
текущим в момент вызова defstruct
<P>
Кроме того, все такие функции могут быть объявлены с помощью
inline, что позволяет несколько повысить эффективность
генерации кода. Этот режим используется по умолчанию, и если вы
не хотите, чтобы какие-либо функции создавались
inline,
то за формой defstruct должно следовать объявление
notinline, которое перекрывает старое, созданное по
умолчанию.
<P>
Однако, это не слишком безопасное решение. Во многих реализациях
Common Lisp результаты переопределения defstruct, то
есть повторные вызовы defstruct  с одним и тем же именем
могут давать непредсказуемые результаты.

<P>
Причина такого поведения состоит в том, что экземпляры структур,
созданных со старыми и новыми определениями могут оказаться
несовместимыми друг с другом. А если функции, ассоциированные со
старым определением были объявлены inline, и
скомпилированы в исполняемый код, то они останутся доступными и
после нового определения, в результате чего код станет
несовместим с новым определением структуры.
<P>
Конечно, такое ограничение оказывает
влияние на разработку и
процесс отладки. Большинство программных сред
Lisp, что
называется &quot;в курсе&quot; проблем переопределения
defstruct, и предусматривают возможность их
переопределения, хотя и с генерацией предупреждающих сообщений о
возможных конфликтах с другими частями программной среды. Однако,
к моменту выпуска готового программного обеспечения все эти
конфликты должны быть улажены разработчиком -- в работающих
программах подобные разногласия недопустимы!

<h2>Использование автоматически порожденной функции
конструктора</h2>

После того, как вы с помощью defstruct определили новую
структуру, вы можете создавать экземпляры структур такого типа с
помощью функции конструктора. По умолчанию defstruct
автоматически определяет такую функцию и генерирует для нее
уникальное имя.


<P>
Например, для структуры с названием foo,
автоматически создается конструктор с названием
make-foo;
впрочем вы можете задать и другое имя, передав его ключевому
аргументу :constructor, или указать, что вы не
нуждаетесь в конструкторе вообще, использовав вместо имени
конструктора NIL.

<P>
В общем случае обращение к функции конструктора имеет вид:
<!--mstheme--></font><pre>
<font color="#000000">(name-of-constructor-function
           slot-keyword-1 form-1
           slot-keyword-2 form-2
       ...)
</font></pre><!--mstheme--><font face="Times New Roman">


<P>
Все аргументы являются ключевыми. Каждое из ключевых слов <i>slot-keyword</i>
должно совпадать с именем компонента структуры.
Оцениваются все ключевые слова ...keyword... и
формы form.... Коротко говоря, это выглядит так, как
если бы функция конструктора получила все свои аргументы как
параметры {&#38;key}. Например, структура ship,
содержит функцию конструктора, которая получает аргументы с помощью
некоторого эквивалента вызова
<!--mstheme--></font><pre>
<font color="#000000">(defun make-ship (&amp;key x-position y-position 
                  x-velocity y-velocity mass) \\
...)
</font></pre><!--mstheme--><font face="Times New Roman">


<P>
Если <i>slot-keyword-j</i> обозначает название компонента, то
каждый элемент созданной структуры будет при инициализации
получать значение формы <i>form-j</i>. Если же для данного
компонента нет пары <i>slot-keyword-j</i> и <i>form-j</i>, значение
компонента инициализируется формой <i>default-init</i>, заданной
для этого компонента при вызове defstruct.


<P>
Другими словами, инициализация, заданная в defstruct,
отменяется, если используется специальный вызов инициализатора
в форме конструктора. Если используется форма инициализации по
умолчанию, то она оценивается во время выполнения конструктора,
но в лексическом контексте defstruct-формы, в которой
она была определена.


<P>
Если в самом вызове defstruct также не предусмотрен
никакой специальный код для инициализации, то начальное значение
элементов остается неопределенным. Впрочем, вы всегда можете
провести инициализацию, либо в вызове defstruct, либо
при вызове функции конструктора. Конечно, это имеет смысл только
в том случае, если начальные значения компонентов имеют какое-то
значение.


<P>
Каждая мз форм инициализации, заданных для компонентов
defstruct, оценивается при каждом вызове функции
конструктора. Понятно, что это может использоваться для получения
весьма нетривиальных результатов.
Например, если в качестве формы инициализации используется форма
(gensym) (либо при вызове функции конструктора, либо как
форма инициализации по умолчанию), то каждый
вызов функции
конструктора будет приводить к однократному вызову
gensym, который в свою очередь, будет создавать новый
символ.

<P>
&nbsp;
<h2>Параметры компонентов defstruct</h2>

<P>
Каждое описание компонента <i>slot-description</i> в вызове
defstruct
может задать один или несколько параметров компонента. Таким
параметры состоят из пар, содержащих ключевое слово и значение
(которое не является оцениваемой формой, а представляет собой
непосредственное значение!).
<P>
Например:
<!--mstheme--></font><pre>
<font color="#000000">(defstruct ship 
  (x-position 0.0 :type short-float) 
  (y-position 0.0 :type short-float)
  (x-velocity 0.0 :type short-float) 
  (y-velocity 0.0 :type short-float) 
  (mass *default-ship-mass* :type short-float :read-only t))
</font></pre><!--mstheme--><font face="Times New Roman">


<P>
Это описание устанавливает, что каждый компонент всегда будет
содержать число с плавающей запятой, записанное в коротком
формате, а также, что последний компонент не может быть изменен
после того, как будет создан очередной экземпляр объекта.

<P>
Ниже следует полный список поддерживаемых параметров компонентов.
<!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman"><b>:type</b><br>
Параметр :type  type
указывает, что содержимое компонента всегда должно иметь один и
тот же тип. Это полностью аналогично определению переменной или
функции и позволяет надежно задать тип результата, возвращаемого
функцией доступа. Следует отметить, что аргумент <i>type</i> не
оценивается, он должен лишь быть правильным спецификатором типа.

<!--msthemelist--><tr><td valign="baseline" width="42"><img src="../../_themes/blueprnt/blubul1d.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Times New Roman"> <b>:read-only</b><br>
Параметр :read-only <i>x</i>, где <i>x</i> не
равно NIL, указывает, что этот компонент не может быть
изменен; он всегда содержит значение, установленное при
конструировании экземпляра структруы. В результате нельзя
использоваться для доступа к этому компоненту функцию
  setf.
Если <i>x</i> равно NIL, этот параметр не оказывает никакого
влияния. Форма аргумента <i>x</i> не оценивается.
<!--msthemelist--></table><!--mstheme--><font face="Times New Roman">

<P>
Обратите внимание, что если задано значение по умолчанию, то
установить параметр компонента нельзя.
<p>
&nbsp;
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>

Теперь вы можете самостоятельно попробовать применить структуры на практике. А в 
следующий раз мы еще раз вернемся к старой доброй
defstruct, 
но обсудим более тонкие моменты, которые позволят получить действительно
полную власть над структурами Common Lisp.


      <p> &nbsp; </p>
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>



      <p> &nbsp; </p>
&nbsp;
<!-- SpyLOG f:0211 -->
<script language="javascript"><!--
Mu="u4689.42.spylog.com";Md=document;Mnv=navigator;Mp=1;
Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();
Mt=(new Date()).getTimezoneOffset();
Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;
My="";
My+="<a href='http://"+Mu+"/cnt?cid=468942&f=3&p="+Mp+"&rn="+Mrn+"' target='_blank'>";
My+="<img src='http://"+Mu+"/cnt?cid=468942&"+Mz+"&r="+escape(Md.referrer)+"&pg="+escape(window.location.href)+"' border=0  width=88 height=31  alt='SpyLOG'>";
My+="</a>";Md.write(My);//--></script><noscript>
<a href="http://u4689.42.spylog.com/cnt?cid=468942&f=3&p=1" target="_blank">
<img src="http://u4689.42.spylog.com/cnt?cid=468942&p=1" alt='SpyLOG' border='0'  width=88 height=31 >
</a></noscript>
<!-- SpyLOG  --><!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p>
<script type="text/javascript"><!--
var yandex_r = Math.round(Math.random() * 100000);
document.write('<sc'+'ript type="text/javascript" src="http://an.yandex.ru/code/14812?rnd=' + yandex_r + '&direct-style=2&direct-limit=4&market-style=0&market-limit=4"></'+'sc'+'ript>');
//--></script>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h5>Послать письмо <a href="mailto:voldemarus@narod.ru">
voldemarus@narod.ru</a> &nbsp;<br>
Авторские права © 2003-2009
Картонная армия<br>
Последнее изменение:
января 09, 2010</h5>
<p></p>
<p></p>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>


