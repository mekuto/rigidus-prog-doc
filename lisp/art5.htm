
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">


<title>GNU Common Lisp - часть 5, программные блоки</title>
<meta name="Microsoft Theme" content="blueprnt 0000, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body bgcolor="#FFFFFF" text="#003399" link="#3366FF" vlink="#9900FF" alink="#000066"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p></p>
<p>&nbsp;<img src="../../images/cartonarmy.gif" alt="[Картонная Армия - от галеры до ракеты!]" border="0" width="468" height="60">
</p>
<p>
<a href="../../index.htm"><img src="../../_derived/home_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Домой" align="middle"></a> <a href="../gcl.htm"><img src="../../_derived/up_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Вверх" align="middle"></a> <a href="../../toc.htm"><img src="../../_derived/toc.htm_cmp_blueprnt000_gbtn.gif" width="95" height="20" border="0" alt="Содержание" align="middle"></a></p>
<p>
<img src="_derived/art5.htm_cmp_blueprnt000_bnr.gif" width="600" height="60" border="0" alt="Программные блоки">
<br>
<a href="art1.htm"><img src="_derived/art1.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - первые шаги" align="middle"></a> <a href="art2.htm"><img src="_derived/art2.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp -атомы и списки" align="middle"></a> <a href="art3.htm"><img src="_derived/art3.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - переменные" align="middle"></a> <a href="art4.htm"><img src="_derived/art4.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Lisp - вызов функций" align="middle"></a> <img src="_derived/art5.htm_cmp_blueprnt000_hbtn_p.gif" width="140" height="60" border="0" alt="Программные блоки" align="middle"> <a href="art6.htm"><img src="_derived/art6.htm_cmp_blueprnt000_hbtn.gif" width="140" height="60" border="0" alt="Структуры данных" align="middle"></a>
</p>
<p>&nbsp;</p>

<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Times New Roman">
<p>&nbsp;</p>
<p><a href="http://">
</a>
</p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Times New Roman">
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>
<h4 align="right">В.Водолазкий</h4>

<h2>Первые шаги в Gnu Common Lisp -
Программные блоки и выход из них</h2>

Конструкции block и return-from предназначены для
реализации механизма выхода за пределы текущего лексического
контекста. Попросту говоря, использование return-from внутри
конструкции block с таким же именем обеспечивает немедленную
передачу управления за пределы данного блока. В большинстве
случаев этот механизм оказывается более эффективным чем передача
управления на базе catch и throw, о чем мы поговорим отдельно.

<h3>Специальная форма  block</h3>
<!--mstheme--></font><pre>
<font color="#000000">block name ,form*
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Конструкция block организует последовательное выполнение
всех форм <i>form</i> слева направо, возвращая результат
вычисления последней формы. Если, однако, во время исполнения
блока выполняется форма return или <code>return-from</code>, имеющая
в качестве аргумента то же имя блока, что и задано в параметре
<i>name</i>, то в качестве результата всей конструкции <code>block</code>
возвращается значение, указываемое с помощью  <code>return</code> или
<code>return-from</code>. Именно этим <code>block</code> отличается от
<code>progn</code>; конструкция <code>progn</code> на форму
<code>return</code> никак не реагирует.
<p>
Параметр <i>name</i> не оценивается и должен представлять собой
символ. Область видимости символа <i>name</i> лексическая ---
только <code>return</code> или <code>return-from</code>, которые текстуально
содержатся внутри одной из форм блока, могут обеспечить выход из
него. Это приводит к тому, что выйти из любого блока (или его
экземпляра) можно только один раз --- либо по завершению его
работы, либо в результате выполнения явной команды возврата.
<p>
Форма <code>defun</code> практически неявно помещает тело определяемой
функции внутрь конструкции <code>block</code>; этот блок имеет имя,
совпадающее с именем функции. Поэтому допускается использовать
выход из функции с помощью вызова  <code>return-from</code>.
<p>
Зона видимости имени блока подчиняется общим правилам лексической
видимости и иногда может приводить к последствиям, которые, по
меньшей мере, удивляют пользователей и разработчиков других
диалектов Лиспа. Например, вызов <code>return-from</code> в приведенном
ниже примере ведет себя вполне предсказуемо:<!--mstheme--></font><pre>
<font color="#000000">(block loser 
   (catch 'stuff 
      (mapcar #'(lambda (x) (if (numberp x) 
                                (hairyfun x) 
                                (return-from loser {nil}))) 
              items)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Однако в ряде ситуаций <code>return</code> в Common Lisp может оказаться
заметно сложнее. Так, <code>return</code> может приводить к разрушению
механизма ловушек прерываний, а также существует вполне реальная
возможность ссылки на несуществующее имя блока, если блок был
``закрыт'' в результате лексического замыкания.

<h3>Специальная форма return-from</h3>
<!--mstheme--></font><pre>
<font color="#000000">return-from name [result]
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Форма <code>return-from</code> используется для возврата из блока 
<code>block</code>, или из подобных ей конструкций  <code>do</code> и <code>prog</code>,
которые неявно используют механизм <code>block</code>.
Имя name не оценивается и должно представлять собой символ.
При этом данная форма должна находиться внутри конструкции <code>block</code>
с таким же именем; если в форме присутствует необязательный
параметр result, то его значение передается как результат
всего блока при выходе. Если же форма  result отсутствует,
то возвращаемый результат будет равен nil. Как правило, такой
вариант используется в тех случаях, когда возвращаемое значение
не представляет никакого интереса.
<p>
Сама по себе форма <code>return-from</code> никогда не возвращает, да и
не имеет собственного значения --- она лишь передает результат
вычислений во внешний мир за пределы конструкции <code>block</code>.
Если результат вычисления  result приводит к генерации
нескольких значений, то при выходе возвращаются все.

<h3> Форма return</h3>
<p>
<br>
<font color="#000000">return [result]<br>
</font><br>
<br>
Форма (return&nbsp; form) по смыслу идентична
конструкции (return-from nil&nbsp; form); она
обеспечивает возврат из безымянного блока (именем
которого является nil). Такие блоки неявно
создаются в итерационных конструкциях,
таких как <code>do</code>, что позволяет
использовать в них <code>return</code>  для
корректного выхода.<br>

<h2>Циклы и итерации</h2>

В составе Common Lisp реализовано несколько конструкций,
ориентированных на итерационное исполнение участков кода.
Прежде всего, это форма <code>loop</code>, которая реализует тривиальную
поддержку итерационных вычислений, и по сути представляет собой
незначительное расширение <code>progn</code> механизмом, который
заставляет, при выполнении некоторого условия повторять
вычисление всего фрагмента кода. Конструкции
<code>do</code> и <code>do*</code> обеспечивают контроль за изменением сразу
нескольких переменных на каждой итерации. Для реализации
специализированных итерационных процедур над элементами списка или
выполнения их ровно  n-раз, предназначены функции
dolist и dotimes. Конструкция tagbody представляет
собой наиболее общий вариант, допускающий использование внутри ее
произвольных передач управления с помощью
go.

<quotE>
Традиционная конструкция <code>prog</code> представляет собой результат
объединения tagbody, <code>block</code>, и let.
</quote>

<h3>Бесконечный цикл</h3>

Конструкция <code>loop</code> представляет собой простейший механизм организации
циклических вычислений. Эта конструкция не предполагает использования
управляющих переменных и просто выполняет свое тело раз за разом.

<h3>Форма loop</h3>
<!--mstheme--></font><pre>
<font color="#000000">loop ,form*
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Каждый из входящих в состав функций параметров-форм form
оценивается последовательно: слева направо. И если оценивается
последняя форма form, то после нее возобновляется
вычисление первой формы, и так далее. В результате образуется
бесконечный цикл вычислений. Конструкция <code>loop</code>, по вполне
понятным причинам, никогда не возвращает значений. Выполнение ее
можно прервать только с помощью явной команды, такой как,
например, <code>return</code> или throw.
<p>
Так же, как и большинство других итерационных механизмов,
<code>loop</code> создает неявный блок с именем {\nil.
Поэтому для выхода из <code>loop</code> может использоваться вызов
<code>return</code>, которому можно передать необходимые результаты.
<p>
Конечно, конструкция <code>loop</code> имеет смысл только в том
случае, если каждая форма form отлична от атома (то есть
является списком). Вариант, при котором форма form
представляет собой атомарное значение, используется в некоторых
современных версиях системы.

<h3>Общие средства для организации итерационных вычислений</h3>

В отличие от <code>loop</code>, <code>do</code> и <code>do*</code> предназначены для
реализации гибкого и мощного механизма организации повторяющихся
вычислений.

<h3>Специальная форма do</h3>
<!--mstheme--></font><pre>
<font color="#000000">do ({var | (var [init [step]])*)
   (end-test {result*)
    declaration* {tag | statement* 
    
do* ({var | (var [init [step]])*)
    (end-test {result*)
    declaration* {tag | statement*
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Специальная форма <code>do</code> предназначена для реализации общего
механизма итераицонных вычислений с произвольным количеством
``итерационных переменных''. Эти переменные используются внутри
тела цикла и их значения обновляются все одновременно вначале каждой
очередной итерации. Переменные могут использоваться как для
генерации последовательности данных (например, последовательных
целых чисел), так и для накопления результатов работы. После
того, как в начале очередной итерации будет выполнено условие
окончания цикла, выполнение конструкции <code>do</code> будет прекращено,
а в качестве значения будет возвращено значение, указанное в
параметре result.
<p>
В общем случае, цикл <code>do</code> выглядит следующим образом :<!--mstheme--></font><pre><font color="#000000">
(do ((var1 init1 step1) 
     (var2 init2 step2) 
     ... 
     (varn initn stepn)) 
    (end-test . result) 
  *declaration 
  . tagbody)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Цикл <code>do*</code> выглядит точно так же, отличаясь только ключевым
словом  <code>do*</code> вначале.
<p>
Первый объект формы представляет собой список из нуля и более
спецификаторов индексных переменных. Каждый из
спецификатора представляет собой список имен переменных
var,
начальное значение init, и форма вычисления очередного
значения step. Если параметр
init пропущен, то по умолчанию он получает значение
NIL.
Если опущен параметр step, то значение переменной var
не изменяется между итерациями <code>do</code>. Впрочем, это не запрещает
внутри цикла <code>do</code> изменять значения этих переменных с помощью
функции setq.
<p>
Спецификатор индексной переменной может также представлять собой
просто имя переменной. В этом случае переменная имеет начальное
значение, равное  NIL и не изменяется от итерации к итерации.
Рекомендуется использовать такую переменную только в тех случаях,
когда эта переменная бкдет получать некоторое значение (например,
с помощью setq) до того, как она впервые будет использована.
Необходимо отметить, что до инициализации начальное значение
равно NIL, и не является неопределенным. И все-таки
рекомендуется не отдавать интерпретацию на волю системы, а явно
указывать (varj NIL), если начальное значение
должно означать ``false,'' или (varj '())
если начальное значение должно представлять собой пустой список.
<p>
Перед тем, как начнется первая итерация, осуществляется оценка
значений всех форм init, а затем каждая переменная
var связывается со значением соответствующей формы
init.
Имейте в виду, что это не присвоение, а связывание; после
окончания цикла будут восстановлены прежние значения этих
переменных.
<p>
В случае <code>do</code>, все формы init
оцениваются до того как будет проведено связывание
какой-либо переменной var; поэтому все формы
init при обращении к переменным с такими именами ссылаются
на их старые связи, то есть на значения, видимые до начала
выполнения конструкции <code>do</code>.
<p>
В случае <code>do*</code>, вначале оценивается первая форма
init,
затем с этим значением связывается первая переменная
var, после этого оценивается вторая форма 
init и с ее результатом связывается вторая
переменная var, и так далее;
в общем случае форма initj может ссылаться на новое
связывание vark, если  k&lt;j,
в противном случае ссылка производится на старую связь
vark.
<p>
Второй параметр цикла представляет собой список, состоящий из
предиката, описывающего условие завершение цикла
end-test и произвольное количество (включая нуль) форм
result.
Фактически, этот фрагмент можно рассматривать как один из
вариантов в формате функции cond. Вначале каждой итерации,
после завершения обработки индексных переменных оценивается
значение предиката end-test. Если результат равен
NIL, то выполнение продолжается, и повторяется
вычисление
фрагмента в форме <code>do</code> (или <code>do*</code>). Если же результат не
равен NIL, оцениваются формы result, в соответствии с
неявным <code>progn</code>,  и после этого 
<code>do</code> завершает работу. Форма <code>do</code> возвращает результаты
оценки последней формы result.
В случае, если формы result отсутствуют, значением <code>do</code>
становится NIL. Конечно, такое поведение не полностью
аналогично работе оператора  cond form, поскольку вариант cond
ьез форм result возвращает результат теста, который, как ис
ледует ожидать, отличен от NIL.
<p>
Вначале каждой итерации, начиная со второй, индексные переменные
обновляются следующим образом. Оцениваются все формы step
слева направо, и все результирующие значения назначаются
соответствующим индексным переменным.
Любая переменная, для которой отсутствует форма 
step никакого нового значения не получает.
В случае формы <code>do</code>, все формы step оцениваются до того,
как будет обновлено значение какой-либо переменной; назначение
значений переменным выполняется параллельно, как при
использовании вызова psetq.
<p>
Поскольку все формы step оцениваются до того, как
изменяется какая-либо из переменных, форма 
step всегда использует  старые значения всех
индексных переменных, даже если до этого уже были проведены
оценки каких-либо форм step.
А вот в <code>do*</code>, оценивается первая форма
step,
затем это значение связывается с первой переменной
var,
после чего оуенивается вторая форма step и ее значение
присваивается второй переменной var, и так далее;
присвоение значений переменным осуществляется последовательно,
как при использовании setq.
В обоих версиях --- <code>do</code> и <code>do*</code>, после обновления значений
индексных переменных производится оценка
end-test, после чего начинается собственно выполнение
очередной итерации.
<p>
Если end-test формы <code>do</code> равен NIL, то условие
теста никогда не будет выполнено. В этом случае тело цикла <code>do</code>
будет выполняться вечно. Выполнение бесконечного цикла может быть
прервано с помощью  <code>return</code>,
<code>return-from</code>, передачей управления с помощью go на
внешний уровень, или с помощью throw.
<p>
Например:
<!--mstheme--></font><pre>
<font color="#000000">(do ((j 0 (+ j 1))) 
    (NIL)                        ; Выполнять вечно
  (format t &quot;{~%Input ~D:&quot; j) 
  (let ((item (read))) 
    (if (null item) (return)     ;Обработка до тех пор, пока не встретится NIL 
        (format t &quot;{~&amp;Output {~D: {~S&quot; j (process item)))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Оставшаяся часть формы  <code>do</code> образует неявную форму
tagbody.
Теги можно использовать внутри тела цикла 
<code>do</code> без каких-либо ограничений, например, для установки точек
передачи управления операторов go внутри тела
цикла. После того, как будет достигнут конец тела 
<code>do</code> бужет инициировано выполнение следующей итерации,
начинающееся с оценки значений форм step.
<p>
Вся форма <code>do</code> заключается в неявную конструкцию <code>block</code> с
именем nil. Поэтому в любой момент для выхода из цикла можно
использовать оператор <code>return</code>.
<p>
В начале тела цикла допускается использование форм
declare.
Эти формы применяются только к коду, содержащемуся в теле 
<code>do</code>, а именно, к связям переменных <code>do</code>, формам
init и step, а также к
формам end-test и result.
<p>
Вот несколько примеров использования цикла <code>do</code>:
<!--mstheme--></font><pre>
<font color="#000000">(do ((i 0 (+ i 1))     ; Устанавливает все NULL-элементы a-vector в нуль 
     (n (length a-vector))) 
    ((= i n)) 
  (when (null (aref a-vector i)) 
    (setf (aref a-vector i) 0)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Конструкция
<!--mstheme--></font><pre><font color="#000000">
(do ((x e (cdr x)) 
     (oldx x x)) 
    ((null x)) 
  body)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
использует механизм параллельного назначения индексных
переменных. При первой итерации значением  oldx является
предыдущее значение x, которое имела эта переменная до
начала выполнения цикла <code>do</code>. По мере выполнения
очередных итераций это значение теряется и oldx содержит то значение,
которое имела переменная x на предыдущей итерации.
<p>
Довольно часто итерационный алгоритм может быть наиболее просто и
ясно реализован непосредственно внутри форм
step функции <code>do</code>, и само тело цикла body просто
остается пустым. Например:
<!--mstheme--></font><pre>
<font color="#000000">(do ((x foo (cdr x)) 
     (y bar (cdr y)) 
     (z '{() (cons (f (car x) (car y)) z))) 
    ((or (null x) (null y)) 
     (nreverse z)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Эта конструкция работает точно так же, как и
<code>(mapcar #'f foo bar)</code>. Обратите внимание, что вычисление
формы step в части z основано на том факте, что все
переменные оцениваются одновременно. Кроме того, стоит заметить,
что тело цикла не используется. И наконец, стоит заметить
нетрадиционное использование nreverse для преобразования
накапливаемого результата работы цикла <code>do</code> в нужное
представление.
<!--mstheme--></font><pre>
<font color="#000000">(defun list-reverse (list) 
       (do ((x list (cdr x)) 
            (y '{() (cons (car x) y))) 
           ((endp x) y)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>

В этом фрагменте интересный момент
заключается в использовании
предиката endp вместо null или atom. Такая
реализация проверки конца списка позволяет реализовать более
устойчивый код.
<p>
Теперь, для рассмотрения организации вложенных циклов,
предположим, что в  env содержится список cons-ячеек.
Car-часть каждой из ячеек представляет собой список
символов, а cdr-часть --- список такой же длины, содержащий
соответствующие символам значения. В принципе такая структура
данных аналогична ассоциативному списку, но разделена на
``кадры''. Назовем эту структуру ``картотекой''. Теперь, для
того, чтобы реализовать функцию извлечения отдельных элементов из
такой структуры данных можно использовать функцию:
<!--mstheme--></font><pre>
<font color="#000000">(defun картотека-поиск (sym картотека) 
       (do ((r картотека (cdr r))) 
           ((null r) NIL) 
         (do ((s (caar r) (cdr s)) 
              (v (cdar r) (cdr v)))
             ((null s)) 
           (when (eq (car s) sym) 
    (return-from картотека-поиск (car v))))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Цикл <code>do</code> легко может быть представлен с помощью более простых
конструкций
<code>block</code>, <code>return</code>, let, <code>loop</code>, tagbody,
и psetq следующим образом:
<!--mstheme--></font><pre>
<font color="#000000">(block nil 
  (let ((var1 init1) 
        (var2 init2) 
        ... 
        (varn initn)) 
    *declaration 
    (loop (when end-test (return (progn . result))) 
          (tagbody . tagbody) 
          (psetq var1 step1 
                 var2 step2*
                 ... 
                 varn stepn))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Цикл <code>do*</code> в основном работает аналогично <code>do</code>, однако
связывание индексных переменных и обновление их значений
производится не параллельно, а последовательно. В целом, это
аналогично описанной выше разнице между 
let и let*, а также между  psetq и setq.

<h3>Простые итерационные конструкции</h3>

Конструкции dolist и dotimes выполняют тело цикла один
раз для каждого из значений, которые последовательно принимаются
одной и той же индексной переменной. Конечно, все это может быть
реализовано с помощью цикла <code>do</code>, но перечисленные выше
механизмы, охватывают довольно большую часть практических случаев.
<p>
Как dolist, так и dotimes осуществляют многократное
вычисление набора выражений. При этом на каждой итерации
осуществляется изменение некоторой индексной переменной, значение
которой доступно внутри тела цикла. Функция dolist
осуществляет последовательный просмотр элементов списка, а 
dotimes осуществляет подстановку целых чисел в диапазоне от
0 до n-1, для произвольного целого числа n,
переданного как параметр при вызове функции.
<p>
Значение любой из этих конструкций может быть сформировано с
помощью необязательной формы result. По умолчанию обе
функции возвращают NIL.
<p>
Для немедленного возврата из форм dolist и dotimes,
может использоваться оператор <code>return</code>, который отменяет
выполнение всех следующих за ним функций; фактически, это
означает, что все тело цикло окружается неявным блоком <code>block</code>
с именем nil.
<p>
Само тело цикла представляет собой неявную конструкцию 
tagbody; оно может содержать теги, которые представляют
собой параметры (цели) операторов go. Кроме того,
допускается использовать в начале тела цикла объявлений 
declare.

<h3>Форма dolist</h3>
<!--mstheme--></font><pre>
<font color="#000000">dolist (var listform [resultform])
       declaration* {tag | statement*}
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Функция dolist выполняет достаточно простую и прямолинейную
итерацию по каждому из элементов списка.
Вначале dolist оценивает значнеие формы listform,
которое должно привести к формированию списка. Затем
осуществляется оценка тела цикла для каждого его элемента, при
этом переменная var связывается на каждой итерации с
очередным элементом.
После того, как будет просмотрен весь список, оценивается
значение формы resultform (должна представлять собой
простою форму, и не может быть неявной <code>progn</code>),
которая возвращается как результат всего вызова dolist.
Во время оценки значения resultform управляющая переменная
цикла var по-прежнему является связанной и имеет значение
nil. Если resultform опущена, функция возвращает NIL.
<p>
Вот пример использования dolist:
<!--mstheme--></font><pre>
<font color="#000000">(dolist (x '(a b c d)) (prin1 x) (princ &quot; &quot;))  ; NIL 
   ; после печати ``a b c d '' (не забудьте о пробеле)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Для немедленного прекращения выполнения цикла и возвращения
заданного значения может быть использован оператор
<code>return</code>.

<h3>Форма dotimes</h3>
<!--mstheme--></font><pre>
<font color="#000000">dotimes (var countform [resultform])
        {declaration* {tag | statement*}}
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Функция dotimes реализует механизм для ``прямолинейного''
цикла, переменная цикла в котором принимает несколько
последовательных целочисленных значений. Выражение 
(dotimes (var countform resultform) . progbody)
осуществляет оценку формы countform, значение которой
должно представлять собой целое число. Затем
производится вычисление тела progbody, которое повторяется
для переменной var, принимающей последовательно значения от
0 по count (не включая последнее значение). Если значение 
countform равно нулю или меньше, то форма
progbody выполняется 0 раз, то есть не выполняется вообще.
И, в заключение, оценивается форма resultform, которая представляет собой
одну форму, и не интерпретируется автоматически как неявный
<code>progn</code>-блок, и ее результат становится результатом всей формы
dotimes. Во время оценки resultform управляющая
переменная var по-прежнему считается связанной, и ее
значение равно количеству выполненных циклов.
Если resultform опущена, результат вычисления всей формы
равен NIL.
<p>
Допускается в любой момент прекратить вычисление цикла с помощью
оператора <code>return</code>, который позволяет вернуть произвольное
значение.
<p>
Вот пример использования dotimes для обработки строк:
<!--mstheme--></font><pre>
<font color="#000000">;;; Предикат  palindromep принимает значение 
;;; True если его аргумент представляет собой палиндром 
;;; (строку, одинаково читающуюся в оба направления). 

(defun palindromep (string &amp;optional 
                           (start 0) 
                           (end (length string))) 
  (dotimes (k (floor (- end start) 2) {\true) 
    (unless (char-equal (char string (+ start k)) 
                        (char string (- end k 1)))
      (return NIL)))) 

(palindromep &quot;Able was I ere I saw Elba&quot;) ; true 
 
(palindromep &quot;А роза упала на лапу Азора&quot;) ; NIL 
 
(remove-if-not #'alpha-char-p     ; Удаление пунктуации 
               &quot;A man, a plan, a canal--Panama!&quot;)
   ; &quot;AmanaplanacanalPanama&quot; 
 
(palindromep 
 (remove-if-not #'alpha-char-p 
                &quot;A man, a plan, a canal--Panama!&quot;)) ;true 
 
(palindromep 
 (remove-if-not 
   #'alpha-char-p 
   &quot;Unremarkable was I ere I saw Elba Kramer, nu?&quot;)) ; true
 
(palindromep 
 (remove-if-not 
   #'alpha-char-p 
   &quot;A man, a plan, a cat, a ham, a yak, 
                   a yam, a hat, a canal--Panama!&quot;)) ; true

(palindromep 
 (remove-if-not 
   #'alpha-char-p 
   &quot;Ja-da, ja-da, ja-da ja-da jing jing jing&quot;)) ; nil
</font></pre><!--mstheme--><font face="Times New Roman">
<p>

Изменение значения var в теле цикла (например, за счет
использования setq) может привести к неопределенным
результатам (Конкретный результат определяется
реализацией Лиспа. Что касается компилятора Common Lisp, то в
таких случаях обычно выдается предупреждение).

<h3>Отображения</h3>

Отображения представляет собой класс итераций, в которых
некоторая функция применяется последовательно к фрагментам одной
или нескольких последовательностей. Результатом выполнения таких
итерационных конструкций становится последовательность,
содержащая результаты применений функции к этим фрагментам. В
Лиспе предусмотрено несколько вариантов, определяющих способы,
которыми осуществляется выбор фрагментов обрабатываемого списка и
что происходит с результатами, получаемыми в результате
приложения функции.
<p>
Для осуществления подобных итераций над произвольными структурами
данных предназначена общая версия функции map. Но более
часто используются описываемые ниже функции, которые работают
только над списками.
<p>

<h3>Функция map*</h3>
<!--mstheme--></font><pre>
<font color="#000000">mapcar function list &amp;rest more-lists 
maplist function list &amp;rest more-lists 
mapc function list &amp;rest more-lists 
mapl function list &amp;rest more-lists 
mapcan function list &amp;rest more-lists 
mapcon function list &amp;rest more-lists
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Для каждой из этих функций отображения первый аргумент
представляет собой функцию, а оставшиеся должны быть списочного
типа. Функция должна принимать столько аргументов, сколько
списков представлено среди параметров map*.
<p>
Функция mapcar работает над последовательными элементами
списков. Вначале, функция применяется к car-части каждого
списка, затем, к cadr-части каждого списка, и так далее.
<p>
<quote>
В идеальном случае все списки должны иметь одинаковую длину, если
же это не так, то выполнение циклов заканчивается, как только
будет достигнут конец самого короткого из них. Оставшиеся
элементы в остальных списках игнорируются.
</quote>
<p>
Значение, возвращаемое mapcar представляет собой список
результатов успешных вызовов функции function.
<p>
Например:
<!--mstheme--></font><pre>
<font color="#000000">(mapcar #'abs '(3 -4 2 -5 -6))     ; (3 4 2 5 6) 
(mapcar #'cons '(a b c) '(1 2 3))  ; ((a . 1) (b . 2) (c . 3))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Функция maplist работает так же, как и mapcar с тем
отличием, что функция применяется к спискам целиком и
последовательно вычисляемым их cdr-частям, а не к их
отдельным элементам. Например:
<!--mstheme--></font><prE>
<font color="#000000">(maplist #'(lambda (x) (cons 'foo x)) 
         '(a b c d)) 
   ;; ((foo a b c d) (foo b c d) (foo c d) (foo d))

(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1))) 
         '(a b a c d b c)) 
   ;; (0 0 1 0 1 1 1) 
   ;;  Элемент равен 1 если соответствующий элемент входного 
   ;;  списка представлял собой последнеий экземпляр этого элемента 
   ;;  во входном списке.
</font></prE><!--mstheme--><font face="Times New Roman">
<p>

Точно так же функции mapl и mapc работают аналогично
maplist и mapcar, однако они не накапливают результаты
вызовов функции function.
<p>
<quote>
Практически во всех Лисп-системах, нначиная с первой, которая
получила распространение в СССР Lisp 1.5, функция 
mapl называлась map. В главе, посвященной работе с
последовательностями, мы рассмотрим, почему такой выбор
представляется неудачным. Поэтому в CommonLisp имя функции  map
используется общей функцией отображения (generic sequence mapper).
</quote>
<p>
Все эти функции используются в тех случаях, когда функция
вызывается ради вносимых ею побочных эффектов, а не ради
возвращаемых значений. Значение, возвращаемое
mapl или mapc это ее второй аргумент, то есть первый
аргумент последовательности.
<p>
Функции mapcan и mapcon работают аналогично mapcar
и maplist, соответственно, за исключением того, что они
комбинируют результаты вызовов функции с помощью
структуроразрушающей nconc вместо list.  Поэтому,
<!--mstheme--></font><pre>
<font color="#000000">(mapcon f x1 ... xn) 
   ; то же что и (apply #'nconc (maplist f x1 ... xn))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>

То же самое справедливо для  mapcan и mapcar.
Образно говоря, эти функции позволяют отображаемой функции
возвращать переменное количество объектов, которые должны
помещаться в выходной список. Это оказывается особенно полезно
если должен быть возвращен всего один объект или даже ни одного:
<!--mstheme--></font><pre>
<font color="#000000">(mapcan #'(lambda (x) (and (numberp x) (list x))) 
        '(a 1 b c 3 4 d 5)) 
   ;; (1 3 4 5)
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
В этом случае функция работает как своеобразный фильтр, собственно
говоря, это стандартный способ использования mapcan в Лиспе.
<p>
<quote>
В этом случае, однако, более предпочтительной может оказаться
функция remove-if-not.
</quote>
<p>
Не забывайте, что nconc представляет собой
структуроразрушающую операцию, а следовательно такими же являются
и использующие ее  mapcan и mapcon;
списки, возвращаемые function разрушаются при формировании
итогового.
<p>
Иногда вместо использования операции отображения может оказаться
более удобным использовать <code>do</code> или простую рекурсию; а
функции отображения используются в тех случаях, когда это
способствует упрощению программы и повышает читаемость кода.
<p>
Функциональный аргумент, используемый в функции отображения
должен представлять собой функцию, которая допустима в качестве
аргумента для apply; поэтому он может представлять собой
макрокоманду или имя специальной формы. Естественно, не
существует никаких противопоказаний в использовании ключевых
параметров  &optional и &rest.
<p>
В некоторых версиях CommonLisp  function может иметь только тип 
symbol или function; использование lambda-выражений
не допускается. Однако, для совместимости со старым программным
обеспечением, да и для удобства работы, можно использовать
специальную форму --- сокращение  <code>#'</code>, помещаемое перед 
lambda-выражением, которое записывается в виде аргумента этой
формы.

<h3>``Program Feature''</h3>

Со времен Lisp 1.5 практически во всех реализациях Лиспа был
реализован некий механизм, который получил название
``the program feature''. Странное название, которое невозможно
адекватно перевести на русский язык  (ну разве что, как
``возможность программирования''., объясняется тем что без этого
механизма просто невозможно разрабатывать программы!)
<p>
Так, конструкция <code>prog</code> позволяет создавать Алгол- или
Фортран-подобные программы, записываемые в процедурном стиле, с
использованием операторов передачи управления go, которые
ссылаются на теги, в теле <code>prog</code>. Однако современный стиль
программирования на Лиспе склоняется к отказу от постоянного
использования <code>prog</code>. Разнообразные итерационные средства,
такие как <code>do</code>, предоставляют возможность без труда реализовывать
<code>prog</code>-подобные конструкции (В то же время, следует
признать, что использование  do без итерационных механизмов
на практике встречается исключительно редко...)
<p>
Конструкция <code>prog</code> осуществляет выполнение трех различных
операций: она осуществляет связывание локальных переменных,
разрешает использование оператора <code>return</code>, и разрешает
использование оператора go. В Common Lisp все эти три
операции разделены на три непересекающихся механизма:
let, <code>block</code>, и tagbody. Эти три средства
используются незавсисимо друг от друга как строительные
кирпичики, составляющие основу других, более сложных конструкций.

<h3>Специальная форма tagbody</h3>
<!--mstheme--></font><pre>
<font color="#000000">tagbody {tag | statement*}
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Часть формы tagbody после списка переменных представляет
собой ее тело. Объект в теле формы может представлять собой
символ, число  (в этом случае он называется тегом),
либо список  (а в этом случае он называется 
оператором). 
<p>
Каждый элемент тела формы обрабатывается последовательно, слева
направо. При этом теги игнорируются; операторы
оцениваются, а результаты оценки отбрасываются. Если достигнут
конец тела, то  tagbody возвращает NIL.
<p>
Если оценивается конструкция (go тег), управление
передается на ту часть тела формы, которая имеет метку
тег.
<p>
Зона видимости тегов, заданных с помощью tagbody является
лексической и после выхода из конструкции tagbody
использование операторов go для переходов к 
тегам внутри ее тела недопустимо. Однако оператор  
go может выполнить передачу управления в tagbody, котор
ая не является самой вложенной конструкцией, содержащей этот
go; теги, задаваемые в tagbody толькор затеняют другие
теги с таким же именем.
<p>
Конечно, лексическая область видимости точек передачи управления
с помомщью go может рассматриваться как глобальная,
поскольку ее общий характер приводит нередко к неприятным
сюрпризам, которые удивляют как пользователей так и разработчиков
других версий Лиспа. Например, в приведенном ниже фрагменте
оператор go работает вполне предсказуемым образом:
<!--mstheme--></font><pre>
<font color="#000000">(tagbody 
   (catch 'stuff 
      (mapcar #'(lambda (x) (if (numberp x) 
                                (hairyfun x)
                                (go lose))) 
		              items)) 
   (return) 
 lose 
   (error &quot;I lost big!&quot;))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Но в некоторых ситуациях, go в Common Lisp ведет себя совсем
не так, как ожидается, и непохож на классический <b>goto</b>.
Так, go может ``разломать'' ловушки catch, если необходимо
получить доступ к точке передачи управления. Кроме того, в случае
лексического замыкания, созданного с помощью function,
становится возможным ссылаться на цель оператора go в
пределах функции, хотя формально этот тег не должен быть иметь
лексической видимости. 
<p>
В спецификации формы имеется ряд, пробелов, которые иногда
используются дляполучения неожиданных результатов. Например,
отсутствует явное запрещение многократного использования одного и
того же тега внутри тела tagbody. И хотя компилятор и
интерпретатор, скорее всего, будут жаловаться на такое поведение,
но никаких критических для приложения действий предпринято,
скорее всего, не будет. Поэтому программисты нередко используют
избыточные теги, такие как --- для форматирования и внесения
комментариев. Например, вот как мог бы функционировать китайский
философ-созерцатель:
<!--mstheme--></font><pre>
<font color="#000000">(defun философ-созерцатель (j) 
  (tagbody --- 
   созерцать   (unless (голоден) (go созерцать)) 
           --- 
           &quot;Не могу есть без палочек.&quot; 
           (Заточить (палочка j)) 
           (Заточить (палочка (mod (+ j 1) 5))) 
           --- 
   лопать     (when (голоден) 
             (mapc #'откушать-по-кусочку 
                   '(дважды-запеченая-свинина кунг-пао-чи-динг 
                     ву-дип-ха мясо-в-апельсиновом-соусе 
                     вермишель)) 
             (go лопать)) 
           --- 
           &quot;Не могу думать с набитым желудком.&quot; 
           (разломать (палочка j)) 
           (разломать (палочка (mod (+ j 1) 5))) 
           --- 
           (if (счастлив) (go созерцать) 
               (переквалифицироваться продавец-амулетов))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>

<h3>Форма prog</h3>
<!--mstheme--></font><pre>
<font color="#000000">prog ({var | (var [init])*) {declaration* {tag | statement* }}
prog* ({var | (var [init])*) {declaration* {tag | statement*}}
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Конструкция <code>prog</code> представляет собой синтез  let, <code>block</code>,
и tagbody, позволяющий связывать переменные, использовать
операторы <code>return</code> и go в одной конструкции. Типичная
конструкция <code>prog</code> выглядит следующим образом:
<!--mstheme--></font><pre>
<font color="#000000">(prog (var1 var2 (var3 init3) var4 (var5 init5)) 
      *declaration 
      statement1 
 tag1 
      statement2 
      statement3 
      statement4 
 tag2 
       statement5 
      ... 
      )
</font></prE><!--mstheme--><font face="Times New Roman">
<p>
Список после ключевого слова <code>prog</code> представляет собой
множество спецификаций осуществляющих связывание переменных
var1, var2, и т.д., которые представляют собой
временные переменные, связывание которых действительно только
внутри <code>prog</code>. Этот список обрабатывается точно так же, как и
список в форме let: вначале в направлении слева направо
оцениваются все формы init (где любая пропущенная форма
init считается равной NIL), а затем все переменные
связваются с полученными результатами одновременно.
Любое объявление  declaration, появляющееся в теле  <code>prog</code>
используется, так, как если бы они были размещены в начале тела
let.
<p>
Тело <code>prog</code> выполняется аналогично конструкции tagbody;
поэтому внутри его может быть использован оператор go.
<p>
Конструкция <code>prog</code> создает неявный блок <code>block</code> с именем
nil, окружающий всю эту конструкцию, что позволяет
использовать оператор <code>return</code> для передачи управления за
пределы конструкции  <code>prog</code>.
<p>
Вот пример использования <code>prog</code>:
<!--mstheme--></font><pre>
<font color="#000000">(defun король-конфузов (w) 
  &quot;Берет в качестве аргумента cons-ячейку из двух списков и 
   создает из нее список cons-ячеек. Можно рассматривать 
   эту функцию как своеобразную молнию.&quot; 
  (prog (x y z)     ; Инициализировать x, y, z в NIL 
        (setq y (car w) z (cdr w)) 
   loop 
        (cond ((null y) (return x)) 
              ((null z) (go err))) 
   rejoin 
        (setq x (cons (cons (car y) (car z)) x)) 
        (setq y (cdr y) z (cdr z)) 
        (go loop) 
   err 
        (cerror &quot;Лишние символы соединяются сами с собой.&quot; 
                &quot;Несовпадение длин списков!   S&quot; y) 
        (setq z y) 
        (go rejoin)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
которое может быть переписано в более ясной форме:
<!--mstheme--></font><pre>
<font color="#000000">(defun королева-ясности (w) 
  &quot;Берет в качестве аргумента cons-ячейку из двух списков и 
   создает из нее список cons-ячеек. Можно рассматривать 
   эту функцию как своеобразную молнию.&quot; 
  (do ((y (car w) (cdr y)) 
       (z (cdr w) (cdr z)) 
       (x '{\empty (cons (cons (car y) (car z)) x))) 
      ((null y) x) 
    (when (null z) 
      (cerror &quot;Лишние символы соединяются сами с собой.&quot; 
              &quot;Несовпадение длин списков!   S&quot; y) 
      (setq z y))))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>

Конструкция <code>prog</code> может быть представлена в терминах более
простых функций <code>block</code>, let, и tagbody следующим
образом:
<!--mstheme--></font><pre>
<font color="#000000">(prog variable-list *declaration . body) 
   ;; (block nil (let variable-list *declaration (tagbody . body)))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Существует также специальная форма prog*, которя почти
эквивалентна <code>prog</code>. Единственное отличие состоит в том, что
prog* осуществляет связывание и инициализацию временных
переменных последовательно, а поэтому форма init для
каждой из них может использовать значения, вычисленные  для
предыдущих переменных.
Поэтому prog* относится к <code>prog</code> как let* к let.
Например,
<!--mstheme--></font><pre>
<font color="#000000">(prog* ((y z) (x (car y))) 
       (return x))
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
возвращает  car-часть значения z.
<p>
Конечно, в последние годы роль <code>prog</code> заметно уменьшилась и
программисты предпочитают использовать специфические конструкции.
Однако общий механизм тем и отличается, что позволяет реализовать
любой частный случай.

<h3>Специальная форма go</h3>
<!--mstheme--></font><pre>
<font color="#000000">go tag
</font></pre><!--mstheme--><font face="Times New Roman">
<p>
Специальная форма (go tag) используется для передачи
управления внутри конструкции tagbody. При этом тег tag
должен представлять собой символ или целое число --- его значение
не оценивается. Оператор go передает управление на точку,
которая помечена тегом, равным в смысле eql аргументу
tag. Если тег с таким именем отсутствует, то проверяются
тела всех конструкций которые лексически содержат tagbody,
если таковые, конечно, существуют. Если все же подходящего тега
отыскать не удастся, фиксируется ошибка.
<p>
Форма go никогда не возвращает никакого значения.
<p>
С точки зрения хорошего стиля программирования
рекомендуется
дважды подумать, прежде чем использовать в программе оператор 
go. В большинстве случаев вместо go можно использовать
итерационные примитивы, вложенные условные формы или даже
<code>return-from</code>. Если же использование go кажется
неизбежным,  то управляющая конструкция, реализуемая с помощью
go должна быть упакована в макроопределение.


      <p> &nbsp; </p>
<!--msthemeseparator--><p align="center"><img src="../../_themes/blueprnt/bluhorsd.gif" width="600" height="10" alt="horizontal rule"></p>



      <p> &nbsp; </p>
&nbsp;
<!-- SpyLOG f:0211 -->
<script language="javascript"><!--
Mu="u4689.42.spylog.com";Md=document;Mnv=navigator;Mp=1;
Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();
Mt=(new Date()).getTimezoneOffset();
Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;
My="";
My+="<a href='http://"+Mu+"/cnt?cid=468942&f=3&p="+Mp+"&rn="+Mrn+"' target='_blank'>";
My+="<img src='http://"+Mu+"/cnt?cid=468942&"+Mz+"&r="+escape(Md.referrer)+"&pg="+escape(window.location.href)+"' border=0  width=88 height=31  alt='SpyLOG'>";
My+="</a>";Md.write(My);//--></script><noscript>
<a href="http://u4689.42.spylog.com/cnt?cid=468942&f=3&p=1" target="_blank">
<img src="http://u4689.42.spylog.com/cnt?cid=468942&p=1" alt='SpyLOG' border='0'  width=88 height=31 >
</a></noscript>
<!-- SpyLOG  --><!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Times New Roman">
<p>
<script type="text/javascript"><!--
var yandex_r = Math.round(Math.random() * 100000);
document.write('<sc'+'ript type="text/javascript" src="http://an.yandex.ru/code/14812?rnd=' + yandex_r + '&direct-style=2&direct-limit=4&market-style=0&market-limit=4"></'+'sc'+'ript>');
//--></script>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h5>Послать письмо <a href="mailto:voldemarus@narod.ru">
voldemarus@narod.ru</a> &nbsp;<br>
Авторские права © 2003-2009
Картонная армия<br>
Последнее изменение:
января 09, 2010</h5>
<p></p>
<p></p>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>


